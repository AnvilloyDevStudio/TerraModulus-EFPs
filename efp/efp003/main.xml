<?xml version="1.1" encoding="UTF-8" ?>
<efp xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../../efp.xsd"
     efp="3" created="2025-01-30" category="informational" status="draft" title="Relictus Review Report">
	<metadata>
		<pullRequests>
			<pullRequest id="4"/>
		</pullRequests>
	</metadata>
	<body>
		<section title="Introduction">
			<content>
				In EFP 2, a plan to review TerraModulus Relictus branch has been made. This EFP describes
				about the report of the entire review process. In the following, the report will be presented
				section by section according to the previously made plan.
			</content>
		</section>
		<section title="Codebase Commentary">
			<content>
				<p>
					The source code was originally reviewed with an order but later reorganized by their
					respective topics and themes. The review has been conducted as of commit
					<code>2ba2b09bf94110efbdc36cd95ce8d74a20835205</code>.
					In the following, various content will be discussed following their headers.
					Please note that the organization of content in this section has been aided by Artificial
					Intelligence (AI).
				</p>
			</content>
			<section title="Application Initialization and Entrypoint">
				<content>
					<p>
						The application framework would include a dedicated <code>Main.kt</code> file,
						designed separately for both client and server implementations. This file contains
						the entry point <code>main</code> function, which is responsible for initializing
						the application, processing command-line arguments, and launching the primary
						handlers essential for execution.
					</p>
				</content>
			</section>
			<section title="Core Structure and System Architecture">
				<content>
					<p>
						Within the <code>core</code> package, several critical components define the
						foundation of the application's architecture.
					</p>
					<p>
						The <code>Game</code> component should be instantiated rather than implemented
						solely through static members or as a singleton. Its designated class name
						would be <code>TerraModulus</code>, with the <code>NAME</code> field defined as
						a top-level constant. Meanwhile, the <code>VERSION</code> field would be managed
						through the application profile, ensuring loading during early runtime and later
						accessibility via a getter method.
					</p>
					<p>
						<code>Initializer</code> class would be incorporated within <code>Main.kt</code>
						file, facilitating the initialization of all core threads required for application
						functionality, such as rendering and ticking threads.
					</p>
					<p>
						The <code>io</code> package would no longer reside within <code>core</code>,
						as its scope is overly generic. At a minimum, several parts would be grouped
						into <code>audio</code> package and the <code>Localization</code> class would be
						separated from it to ensure modular organization. Furthermore, all display elements
						would be registered directly to the menu, allowing a simple reload operation to
						refresh all elements without reliance on external hooks.
					</p>
					<p>
						Ticking operations would be centrally managed within the <code>TerraModulus</code>
						class. Specifically, menu ticking would be executed there, necessitating that
						<code>MenuManager</code> be placed outside <code>RenderSystem</code>, although
						rendering would still take it as a parameter. World ticking would be handled by
						its respective manager, while audio processing would operate in a separate thread
						under the control of the audio system.
					</p>
					<p>
						To enhance clarity, <code>Display</code> would be renamed to <code>Screen</code>.
						Instead of retaining the original <code>Screen</code> class, a <code>Canvas</code>
						may be introduced to manage display elements more effectively. Screen transitions
						would continue to follow a Last-In-First-Out (LIFO) linked list structure;
						however, improvements could be made to the handling of screen initialization
						and exit procedures. Rather than relying on an initializing function, a
						constructor reference could be utilized, particularly since the parent instance
						parameter is primarily intended for rendering. Passing a constructor function
						and managing parent screens within <code>MenuManager</code> would offer a more
						streamlined approach.
					</p>
				</content>
			</section>
			<section title="Window Management and Handling">
				<content>
					<p>
						Similarly, the <code>Initializer</code> class should avoid the use of static
						members. Window management would be handled through a dedicated window handler,
						which could also oversee error popups when necessary. FPS (Frames Per Second) and
						TPS (Ticks Per Second) counters would be regulated within their respective handler
						classes, ensuring proper thread management.
					</p>
					<p>
						Additionally, the application window would be launched at an early stage,
						following the initialization of essential basic elements. This approach eliminates
						the necessity of a splash screen without a visible window. The window would always
						be centered upon launch to ensure a consistent user experience.
					</p>
					<p>
						Argument parsing would be handled within the <code>Main.kt</code> file, reinforcing
						a structured approach to processing runtime configurations. The <code>run</code>
						function would reside within the <code>TerraModulus</code> class. Moreover, the
						<code>getExceptionTrace</code> function could potentially be repurposed for
						detailed error reporting, contributing to improved debugging and system reliability.
					</p>
				</content>
			</section>
			<section title="Launching Arguments and Options">
				<content>
					<p>
						The launching arguments would be systematically structured, with all options named
						using kebab case, each prefixed with double hyphens. Hardware acceleration would be
						enabled by default; however, a specific launch option to disable it would also be
						available. The fullscreen parameter would function as a toggle, determining whether
						the application starts in fullscreen mode. Regardless of the fullscreen setting, the
						window size configuration would always be applied. If no specific window dimensions
						were provided, default values would be used to ensure a consistent display.
					</p>
				</content>
			</section>
			<section title="Internal Assets">
				<content>
					<p>
						Certain assets that are not intended for modularization or customization may be
						designated as internal components. Unless explicitly required, these resources,
						including logos, would remain at the root level rather than being organized into
						separate directories.
					</p>
				</content>
			</section>
			<section title="Input Handling and Management Architecture">
				<content>
					<p>
						The <code>ClipboardHandler</code> would be managed within the broader
						<code>InputHandler</code>, as all input interactions, including keyboard and
						mouse operations, would be handled via GLFW (Graphics Library Framework).
						Consequently, there would be no necessity to implement separate interfaces for
						key input processing. The menu structure would also undergo modifications to
						ensure that key inputs are detected only by the relevant menu elements, following
						a prioritized approach.
					</p>
					<p>
						The <code>InputHandler</code> oversees several functionalities, including input
						processing, key mapping, controller states, and key state handling. However,
						controller management would be separated into a dedicated
						<code>ControllerManager</code>. The capability of the originally used gamepad library
						is relatively limited, necessitating enhancements in controller support. The abstract
						<code>Key</code> class and its subclasses provide essential functionality, and
						repeated key states would no longer be required. Consequently,
						<code>PhysicalKey</code> could be simplified, and <code>ControllerKey</code> would
						be deemed unnecessary. Additionally, logical operations such as "or" and "and" could
						be incorporated within the <code>Key</code> class. String-based expressions would
						be deprecated, and the <code>PhysicalKey#stayDown</code> function would likely be
						disregarded. Moreover, if key state processing results in a single <code>Key</code>
						state, subclasses such as <code>CompoundedKey</code> and <code>ORKey</code> would
						no longer be required. Key mapping would employ a distinct class rather than relying
						on the <code>Key</code> class.
					</p>
					<p>
						To improve organization and efficiency, input handling would be structured into
						four distinct classes: <code>KeyInputHandler</code>, <code>TextInputHandler</code>,
						<code>GamepadInputHandler</code>, and <code>MouseInputHandler</code>. Among these,
						<code>TextInputHandler</code> would also manage clipboard operations. Text input
						queues would be processed only upon request and reset at the start of each tick
						cycle. A regex filter could be implemented for validation, and backspace key
						operations would follow the same structured processing method. The
						<code>releaseAll</code> method would be omitted, while key hints or hotkeys, despite
						being complex, would likely follow a similar implementation method. Modifier keys
						would not be handled separately within the handler class. Controller vibration
						feedback would be managed by <code>ControllerManager</code> or another dedicated
						class, but controller detection and management would remain within
						<code>ControllerManager</code>.
					</p>
				</content>
			</section>
			<section title="Key Input Event Processing">
				<content>
					<p>
						Key input events triggered by GLFW would be received and queued within the main
						ticking thread. Text inputs would be restricted exclusively to text input fields,
						while keyboard inputs would remain universally active. Each keystroke transitions
						through three states: "just pressed," "down," and "just released," represented as
						boolean values. A press event sets "just pressed" and "down" to <code>true</code>,
						while a release event sets "down" to false and "just released" to <code>true</code>.
						At the start of each input tick, both "just pressed" and "just released" states
						would be reset to <code>false</code>. Subsequently, queued input events would be
						processed, updating key states accordingly, followed by window ticking operations
						that handle input. The ticking frequency might be set to 1.5 times the maximum FPS.
						If necessary, an additional ticking thread operating at a constant frequency could
						be introduced.
					</p>
					<p>
						For events such as controller port interactions, listener callbacks would be
						used instead of polling events each tick. These events occur infrequently and would
						be best handled asynchronously to prevent unnecessary processing overhead.
						Furthermore, GLFW-generated controller events inherently include the target
						controller information, eliminating the need for additional search operations.
						<code>GamepadInputHandler</code> would likely be activated only when controllers
						are enabled.
					</p>
				</content>
			</section>
			<section title="Input Mapping and Key Assignments">
				<content>
					<p>
						Input mapping would be managed separately from the input handler, allowing
						configurations based on user preferences while keeping certain mappings hardcoded.
						This includes the F3 debug key and advanced modifier functionalities involving
						<kbd>Shift</kbd>, <kbd>Ctrl</kbd>, and <kbd>Alt</kbd> modifiers. In-game inputs
						and controllers would follow similar processing principles and be handled within
						the same class structure. Mapped hotkeys would remain inactive when input fields
						are engaged, allowing standard printed key inputs while ensuring hardcoded keys
						such as escape and enter receive the appropriate handling, especially in one-line
						field or with an Input Method Editor (IME).
					</p>
					<p>
						Key mapping would employ predefined sets with the keys of constants rather than
						arbitrary string-based assignments, ensuring clarity in configuration and
						eliminating the need for loops. Mapping would strictly serve logical purposes,
						while a separate display mapping would exist for User Interface (UI) representation.
						Since the mapping configurations would only be used internally in the program, the
						necessity to use string representation would be ineffective. The mapping would be
						hardcoded, so a loop would not be used. The final input states resulting from triggered
						events would be logically combined using "or" operations to ensure all inputs are
						properly accounted for. However, no sticky key would be realized for this system.
					</p>
				</content>
			</section>
			<section title="Keyboard-Based Movement for Tile Selection">
				<content>
					<p>
						To optimize keyboard interactions for movement and tile selection, two potential
						input schemes may be considered. One approach involves using movement keys
						exclusively, with the selected tile automatically aligning with the tile positioned
						in front of the player. Alternatively, a dual-set input method could be implemented,
						where one set of keys (e.g., WASD) controls movement, while another set (e.g., arrow
						keys) allows independent tile selection by directional input.
					</p>
				</content>
			</section>
			<section title="Controller Management and On-Screen Keyboard Integration">
				<content>
					<p>
						Controller management would be enhanced through GLFW, allowing users to select
						their preferred controller. This configuration option would be adjustable via
						settings but would not be stored persistently on disk. Additionally, the On-Screen
						Keyboard (OSK) for controllers would remain available, with notable improvements to
						its underlying functionality.
					</p>
					<p>
						The <code>OnScreenKeyboardMenu</code> would likely retain its existing name but would
						include a constructor parameter accepting an input field object. A menu handle for
						the screen might also be passed, although the exact implementation remains uncertain.
						Alternatively, the OSK could function as an "invisible" menu or component, meaning it
						would be excluded from ticking and rendering processes unless actively required.
					</p>
					<p>
						Given the potential variation in key sizes, keys should be mapped through reference
						linking as components rather than predefined layouts. If a key reference is
						<code>null</code>, it would indicate that no accessible keys exist in that direction.
						Navigation would still be managed via the D-Pad, ensuring seamless controller-based
						interaction. The sticky key's state would be stored within the key object itself,
						which would also be linked to its final property. A grid layout may be employed to
						organize key positioning efficiently.
					</p>
					<p>
						All key states including whether a key is pressed or selected, would be maintained
						within the key object. The OSK would operate independently of traditional keyboard
						input and would automatically hide itself whenever no controller is detected during
						a tick cycle. Key event triggers from the OSK would be directed to the associated
						input field for processing.
					</p>
					<p>
						To ensure flexibility, an abstract class would be introduced, eliminating the need
						for <code>\0</code> as a placeholder for sticky keys. This structure would also allow
						for specialized keys that perform actions beyond text entry, such as the switch key
						to the layout of numeric and symbolic keys. Positioning would not rely on x and y
						coordinates since they are unnecessary for this implementation. Exception should not
						be abused, but managed directly within the input field instance and corresponding
						menu components. Visibility checks within the ticking function would be unnecessary,
						and rendering could be simplified by incorporating sprites into components.
					</p>
				</content>
			</section>
			<section title="Key Mapping Configuration and Restriction">
				<content>
					<p>
						During key mapping configuration, upon the first key release event, all keys
						pressed concurrently would be recorded as a key combination. However, specific
						keys, including escape, menu, and Windows keys, would be restricted from inclusion
						due to contextual compatibility requirements. The escape key would also function
						as a cancellation trigger during key detection. Notably, the escape key would
						remain hardcoded for menu control operations.
					</p>
				</content>
			</section>
			<section title="Hotkey Configurations and Key Sets">
				<content>
					<p>
						Dropping an entire item stack would be executed using the sneaking modifier
						alongside the drop hotkey. If the configured drop key sequence includes the
						sneak key, it would be considered a conflict. Each mapping would define a set
						of permitted keys within a predefined constant.
					</p>
					<p>
						<b>Permitted key sets</b>:
						<list>
							<li>
								<b>Typing Keys</b>: Letters, numbers, and punctuation characters on the
								main keypad, excluding modifiers
							</li>
							<li>
								<b>Control Keys</b>: <kbd>Ctrl</kbd>, <kbd>Alt</kbd>, <kbd>Shift</kbd>,
								<kbd>Tab</kbd>, <kbd>Enter</kbd>, <kbd>Esc</kbd>, <kbd>Enter</kbd>,
								<kbd>Backspace</kbd>, <kbd>Pause/Break</kbd>, <kbd>Insert</kbd>,
								<kbd>Delete</kbd>
							</li>
							<li><b>Function Keys</b>: <kbd>F1</kbd> to <kbd>F12</kbd></li>
							<li>
								<b>Navigation Keys</b>: <kbd>Home</kbd>, <kbd>End</kbd>,
								<kbd>Page Up</kbd>, <kbd>Page Down</kbd>
							</li>
							<li>
								<b>Numpad Keys</b>: All numpad keys except <kbd>Num Lock</kbd>
							</li>
							<li>
								<b>Forbidden Keys</b>: System-wide reserved keys, including
								lock keys, <kbd>Win</kbd>, <kbd>Context</kbd>, <kbd>Print Screen</kbd>
							</li>
						</list>
					</p>
					<p>
						Although <kbd>Tab</kbd> could be categorized as a navigation key, it has been
						excluded from that set to avoid redundancy. Unlisted keys may be disregarded.
						While checking conflicts, hardcoded keys would be taken into account to ensure
						compatibility.
					</p>
				</content>
			</section>
			<section title="Debugging Mechanisms and Interface Adjustments">
				<content>
					<p>
						Debugging functionality would be refined to ensure consistency and ease of access.
						Hotkeys related to <kbd>F3</kbd>, primarily used for toggling the debug screen,
						would remain hardcoded rather than being configurable. To maintain code consistency,
						an invisible menu session would be introduced to process both standalone <kbd>F3</kbd>
						inputs and key combinations involving <kbd>F3</kbd>. The session would activate upon
						pressing <kbd>F3</kbd> and deactivate upon sending a command or releasing the key.
						It would exclusively handle key inputs, triggering commands when applicable. For
						most keys, a direct command would be dispatched to a target, such as toggling
						debugging functions. Otherwise, upon release, the system would verify whether an
						advanced input session had been engaged. If no such session was detected, the
						debug screen toggle would be executed.
					</p>
					<p>
						Additionally, the <code>DebugPanelDisplay</code>, functioning as a Graphical User
						Interface (GUI) for commands may be deprecated if command support is fully integrated.
						Maintaining this panel would introduce unnecessary complexity, and using in-game chat
						for commands could provide a more efficient approach. Many entries currently depend
						on this menu, and transitioning to command-based interactions would simplify the
						interface.
					</p>
					<p>
						Likewise, the <code>ListItemSelectDisplay</code> could be restructured as a menu
						dialog. However, since it is exclusively utilized by the debug panel, its
						implementation would be unnecessary. Consequently, associated entries within
						<code>screen.entry.commands</code> would also be removed.
					</p>
				</content>
			</section>
			<section title="Logging System and Configuration">
				<content>
					<p>
						All application events would be logged irrespective of severity levels,
						eliminating the need for separate logging, debugging, or tracing launch options.
						Debugging functionality would be universally available, with selective toggling
						permitted in specific areas. Given the ease of creating user-generated content,
						debugging would be equally accessible. By structuring each class with a single
						responsibility, logging targets would be clearly identifiable via fully
						qualified class names, eliminating the necessity for arbitrary behavior-specific
						"title names". Log4j 2, SLF4J, and kotlin-logging would serve as the primary
						logging utilities.
					</p>
					<p>
						The logging system would transition to a different library for improved idiomatic
						usage. This change would introduce extensive logging configuration capabilities
						supported by both the library and its public interface. In adherence to Kotlin’s
						idiomatic principles, loggers would not be manually instantiated in external
						classes but would be defined based on descriptive class names. This approach
						ensures syntactic consistency and eliminates the need for custom target names.
						Since the console would typically be hidden from users, log output would remain
						as comprehensive as file-appended logs, without filtering. Additionally, logging
						configurations would be exclusively managed via programmed code, negating the
						need for customizable configurations. Notably, the Rust components of the
						application would not incorporate any logging mechanisms.
					</p>
				</content>
			</section>
			<section title="Localization and Language Settings">
				<content>
					<p>
						The debug locale would no longer be necessary, as untranslated strings would
						already be logged, ensuring careful programming without requiring translation
						key displays on-screen. Localization files would be stored within assets, with
						detailed implementation depending on the new asset system. Instead of a dedicated
						debug locale, a hotkey-based feature could highlight untranslated UI components
						dynamically. Since all entries would already be loaded into memory, switching
						languages would not require additional loading processes.
					</p>
					<p>
						Language settings would be structured as an inner class within the main settings
						system, aligning with preferences. With the debug locale removed, sorting would
						be further simplified. GUI improvements would eliminate the need for entry
						highlighting; instead, selected options could be bordered, bolded, or tinted in a
						distinguishable color. Upon exiting the menu, the chosen entry would be applied
						immediately, negating the need for a "save" button. The translation disclaimer
						could remain, while an option to force Unicode font would not be needed.
					</p>
				</content>
			</section>
			<section title="Settings Organization and UI Integration">
				<content>
					<p>
						The <code>Settings</code> system would transition to <code>Preferences</code>,
						ensuring that setting values remain independent of UI components. UI elements
						should be designed to reference and link to these settings rather than being
						treated as direct entries. World generation configurations would exist solely
						within the world generation options rather than being global entries.
						Additionally, all settings would be structured as type-specified property entries
					</p>
					<p>
						The settings screen would be unified as <code>SettingsScreen</code> rather than
						maintaining separate <code>OptionsMainMenuDisplay</code> and
						<code>OptionsWorldDisplay</code>. There would be no functional distinction
						between the settings accessible from the main menu and those available during
						gameplay. Each option would store both its original and current values, allowing
						for comparison during saving and providing a notification if changes have been
						made. Further settings menus would be instantiated only upon access, reducing
						unnecessary memory usage. The layout structure would primarily follow two models:
						<i>Submenus</i> or <i>Tabs</i> navigation, depending on stylistic choices.
						Changes would only be applied upon exiting the settings menu. Additionally,
						submenu-related buttons would end with an ellipsis when following a submenu-based
						layout.
					</p>
					<p>
						Applying changes only when menus are closed would be a more effective approach
						for managing settings. As multiple submenus may exist within the settings
						interface, UI elements linked to settings values should update exclusively upon
						menu closure. This approach would prevent frequent and potentially disruptive
						effects when users modify settings multiple times within a session.
					</p>
					<p>
						To establish clear distinctions, the following definitions apply:
						<list>
							<li>
								<b>Settings</b>: The overarching system within an application that governs
								configurations and operational adjustments, controlling various features and
								functionalities
							</li>
							<li>
								<b>Options</b>: Specific choices within a context, often presented as a list
								or menu, allowing users to customize their experience or performing specific
								actions
							</li>
							<li>
								<b>Preferences</b>: User-defined selections that determine application
								behavior, stored persistently
							</li>
							<li>
								<b>Configurations</b>: The structural setup of an application’s parameters
								and options determining behaviors and structures of application or system,
								specifying how components interact.
							</li>
						</list>
						Within this context, "Settings" encapsulates the entire configurable system,
						encompassing various "Options", while "Preferences" store individual user
						selections on disk. "Configurations" would not be used in this context.
					</p>
				</content>
			</section>
			<section title="Error Handling and Management">
				<content>
					<p>
						To ensure robust error management, the default uncaught exception handler
						should be initialized as early as possible. This approach guarantees that any
						uncaught exceptions are properly handled and users receive relevant notifications.
						Instead of referencing a separate function, a lambda expression should be
						used, allowing for greater flexibility in error processing. The error message
						content should be distinct from other caught exceptions to facilitate clear
						differentiation.
					</p>
					<p>
						Errors should trigger informational pop-ups only under specific conditions:
						if they occur before rendering initialization is complete, or if they fall
						within or outside the scope of the application. For error catching mechanisms,
						only documented errors should be considered, unless they are managed within
						the primary exception handler or a designated error processing block.
					</p>
				</content>
			</section>
			<section title="Screen System and UI Management">
				<content>
					<p>
						<p>
							The <code>RenderingLimitingModel</code> is an ineffective implementation,
							as scaling the UI and managing menus more efficiently would eliminate the
							need for excessive stretching and scrolling of entries. Components such
							as <code>ScreenEntry</code> and <code>EntryRenderingUnit</code> function
							more as workarounds rather than solutions, making them visually and
							structurally inadequate. A more refined approach using OpenGL would be
							pursued.
						</p>
						<p>
							The <code>screen</code> package, excluding its subclasses, originally
							contained only <code>Display</code>, <code>Menu</code>, <code>Toast</code>,
							<code>TutorialDisplayHandler</code>, and <code>RelPos</code>. The term
							"display" by definition in dictionary refers to a monitor display, whereas
							"screens" typically denote sets of visual components presented on the
							window canvas.
						</p>
						<p>
							The title screen would be enhanced with a background, with selectable
							entries featuring highlights rather than arrow-based indicators. It
							would include a logo, menu entries, a version string and customizable
							title texts via asset packs instead of hardcoded conditions. "Splashes"
							may be renamed to "title texts" as they may no longer visually <i>splash</i>.
							A help message at the bottom would be unnecessary when mouse support is
							enabled by default. The version string would be expanded with additional
							details. Converting UI elements into distinct components, similar to Java
							Abstract Window Toolkit (AWT) or Swing, would eliminate redundant position
							recalculations each frame, improving code quality and scope management.
							The <code>init</code>function in <code>TitleDisplay</code> should not
							handle elements related to screen appearance. The "Play" menu entry would
							be replaced with separate "Singleplayer" and "Multiplayer" options, followed
							by "Settings". Achievements would not be included at this stage. The compact
							"Help" menu, with only four entries, would function as a dialog menu for
							simplicity. Any layout that completely replaces or overlays existing canvas
							components would be categorized as a screen with content as menus and
							components, while entry-based structures would be grouped within a menu.
							The title screen entries would include "Help" and "Quit". The
							<code>PlayDisplay</code>has already been deprecated, with its two entries
							merged into the<code>TitleDisplay</code> as aforementioned.
						</p>
						<p>
							Many screen menus would restrict the <kbd>Esc</kbd> key from returning
							to the previous screen. When screens permit navigation back to prior
							screens, a dedicated return button would be provided to prevent users
							from unintentionally losing progress.
						</p>
						<p>
							Only the top-most screen would be interactive. If an upper screen fully
							covers lower screens, those lower screens would not be rendered. The
							gameplay canvas would also function as a <code>Screen</code> to allow
							for unified management via <code>ScreenManager</code>. When the gameplay
							screen is instantiated, it would become the base screen, with all other
							screens removed. Similarly, initiating a world-loading screen would clear
							all other screens.
						</p>
					</p>
				</content>
			</section>
			<section title="Screen Structure and Component-Based Menu Redesign">
				<content>
					<p>
						<code>Display</code> would be redefined as an abstract class and renamed
						<code>Screen</code>. However, the <code>parent</code> reference would not
						be managed within this class but by the screen manager. Additional
						functionality would be introduced to enhance menu-related features.
						<code>clearScreen</code> would be removed, and <code>canExit</code> could
						be replaced by an overridable function or a callable screen handle for the
						screen. The class structure would resemble a panel rather than a conventional
						<code>Display</code>. Menu <code>selection</code> would primarily support
						keyboard controls, but tab-based navigation would likely suffice.
						Arrow-key-based selection would align with layout structures, such as
						AWT-style grid or border layouts, rather than relying on manual position
						adjustments. <code>onSelectionChange</code> may not be necessary, except
						in cases where it facilitates access to hidden menus through key selection
						or mouse hovering when only selectable components are involved. The rendering
						mechanism would be revised, removing dependencies on selection index for
						rendering depth.
					</p>
					<p>
						Each menu would have a distinct content structure. Instead of
						<code>ListEntry</code>, component-based implementations would be adapted,
						making <code>removeSelectedEntry</code> obsolete. The system would adopt
						a model similar to AWT or Swing. The stack-handling approach in
						<code>InventoryMenu</code> requires further refinement.
					</p>
					<p>
						As <code>ItemListMenu</code> transitions to slot-based design, display length
						constraints would no longer be necessary. Likewise, cutting and aligning
						entries manually would become obsolete, allowing the removal of the
						positioning parameter. The menu construction process would prioritize
						flexibility through component-based design, including padding adjustments.
					</p>
					<p>
						<code>Menu</code> would evolve into a generalized component container rather
						than an entry-based structure. It would not contain entries by default, and
						container-like components managing entries (such as <code>ListEntry</code>)
						would be handled separately. A foundational abstract menu would exclude
						properties such as size, position, title, spacing, frame, selectability,
						rendering, and searching, maintaining minimal structural dependencies. The
						menu would encapsulate a container, passed as a protected final parameter
						via constructor delegation. Components would be managed independently of menus,
						which can exclusively handle components. <code>Screen</code> would follow a
						similar concept but would extend its functionality to directly accommodate both
						components and menus. The builder and copy constructor patterns currently in
						use are inefficient and would be reconsidered.
					</p>
					<p>
						The searching functionality would be independent of <code>Menu</code>,
						incorporated only when a container requires it. This mechanism would be
						powered by an input field and contextual filtering logic rather than fragile
						highlighting and excessive scrolling adjustments. Searching would be performed
						only upon <kbd>Enter</kbd> activation and would deactivate upon
						<kbd>Escape</kbd>. Component rendering would be should on relative positioning,
						eliminating the need for additional translation functions. Visibility states may
						be introduced, and some containers may support listeners. Scrolling animations
						introduce unnecessary complexity and would be removed, along with dynamic
						entry updates, builders, and <code>MenuListEntry</code>.
					</p>
				</content>
			</section>
			<section title="Input Masking and Interactivity Management">
				<content>
					<p>
						An input masking session would be introduced for each tick to regulate input
						state checking in menus. This session would be managed by
						<code>MenuManager</code>, allowing specific menu interactions to suppress or
						fully override queued inputs dynamically. Such modifications would occur on
						demand without affecting physical key detection outside the menu ticking session.
						While its necessity and practicality need further evaluation, this system could
						improve interaction consistency across menus and screens.
					</p>
					<p>
						Components would not reference a menu or screen handle when ticking, while
						menus should always receive the screen handle upon screen ticking. Handles
						and functionality would be managed within screens and menus, even for locally
						defined components. Some menus may require fixed frames, though not all would.
						Rendering functions should be consistently present across screens, menus, and
						components.
					</p>
				</content>
			</section>
			<section title="Inventory System and Menu Organization">
				<content>
					<p>
						An abstract <code>InventoryScreen</code> class would be introduced, serving
						as the foundation for all menu screens incorporating player inventory
						functionality. This class would encompass player inventory menus, crafting
						interfaces, and container menus, but not book-related screens. Every inventory
						menu would include an item counter, distinct from the item list menu, which
						would remain designated for the creative mode item list. Additionally, the OSK
						menu should be controlled by an input field rather than parent menus, enabling
						flexible dynamic menu additions with prioritized handling.
					</p>
					<p>
						For screens such as <code>ContainerDisplay</code> with dual-sided menus,
						directional controls should be used without any cyclic traversal across menus.
						Vertical menus, however, may require different handling due to their inherent
						connectivity, potentially using <kbd>Tab</kbd> for navigation. Notably, slot
						selection and stack transfers between menus would be available exclusively when
						the mouse is disabled for ketboard controls, preventing conflicts with
						mouse-driven interactions, similar to tile selection via keyboard controls.
						The <code>getOtherIdx</code> function lacks relevance under this system, and
						determining control behavior based on cursor position introduces unnecessary
						complexity. A standardized control mechanism would be implemented, with a
						refined naming convention replacing "heaviness". Additionally, color fading
						should be implemented via the alpha channel.
					</p>
				</content>
			</section>
			<section title="Crafting and Recipe System">
				<content>
					<p>
						The <code>CraftingDisplay</code> would be integrated into
						<code>PlayerInvDisplay</code>, which would subsequently be renamed
						<code>PlayerInventoryScreen</code>. Depending on the implementation approach,
						further specialization may be introduced via subclasses such as
						<code>SurvivalPlayerInventoryScreen</code> and
						<code>CreativePlayerInventoryScreen</code>, ensuring logical consistency with
						the overall code style. While the recipe system remains undecided, relevant
						crafting menus and recipe unlocking mechanics would be addressed in conjunction
						with its development. The achievement acquisition method would be revised, as
						the current implementation is excessively hardcoded. Additionally, inventory
						change listeners could be introduced if necessary to refine the refresh
						functionality.
					</p>
					<p>
						A new recipe system would be introduced, recipe menus and crafting menus
						would be greatly changed, since all the crafting mechanisms are too similar.
						Most critically, crafting menus would integrate player storage visibility to
						enhance inventory interaction.
					</p>
				</content>
			</section>
			<section title="Inventory Structure and Management">
				<content>
					<p>
						The <code>InventoryMenu</code> would accommodate a holder, though not
						necessarily limited to an entity. Inventory contents would be linked to the
						holder’s inventory, ensuring bidirectional synchronization of updates. Slot
						alignment would not be enforced, allowing menu slots to correspond directly
						with inventory slots without rigid structuring. The creative inventory would
						not be managed within this system, as previously discussed. Inventory menu slots
						would register listeners at either the inventory or menu level, depending on
						their nature: temporary slots, such as those in crafting interfaces, would be
						handled within the menu, whereas persistent slots (i.e., inventory slots) would
						be registered within the inventory. Since inventory modifications can occur
						outside direct menu interactions, listener registration at the inventory level,
						potentially via the holder, would be necessary.
					</p>
					<p>
						Item stack operations would be managed by the item list menu, with a
						well-defined structure supporting both non-inventory item collections and
						inventory-based stacks. A wrapper class may be introduced for streamlined
						handling, though further implementation details remain to be determined. The
						<code>refresh</code> function may be unnecessary for menu frame updates, while
						the description menu would become a tooltip or a separate menu aside.
					</p>
				</content>
			</section>
			<section title="Inventory Screen and Slot Interaction">
				<content>
					<p>
						Some aspects of <code>PlayerInvDisplay</code> align with previously discussed
						elements. The creative mode item list would be accessible through an
						independent menu or a tab. The selected slot would be bordered or highlighted,
						with item stacks appearing at the cursor while hovering over inventory menus,
						leaving the source slot empty, or remaining in the source slot as a reference
						for interaction. No help text should be shown, eliminating the method used to
						hide the item list menu.
					</p>
					<p>
						The <code>RepairBenchDisplay</code> would retain its inventory menu structure,
						though storage slots would be preferable to temporary ones, replacing
						<code>RepairBenchCarrier</code>. While this approach introduces a new paradigm
						within the codebase, <code>SlotEntry</code> would transition from an entry-based
						system to a direct slot representation. Menus managing stack transfers currently
						follow repetitive processes, which could be simplified through an optimized
						transfer model. Each slot component would maintain an association with its
						backing inventory slot instance. Disabled buttons and empty slots would remain
						selectable but non-interactive. Storage spaces would feature attributes or
						properties defining their slot types, such as crafting input slots, product slots,
						and other specialized configurations. Fishing rod durability tracking could be
						simplified to simplify tool mechanisms. The functionalities of slot entries would
						predominantly depend on their associated backing slots. <code>RepairInfo</code>
						would be regarded as a context generated by the input items, while the carrier
						component primarily delineates operational scope within the display class. The
						current method of using leading spaces for positioning within strings is
						problematic but common within the codebase; replacing slot labels with intuitive
						graphical elements would improve clarity. The <code>onAction</code> function,
						currently used only once within a specific scope, could be refactored into a
						lambda. The redundant "checking again" mechanism should be converted into
						assertions, as its execution is intentional. Stack movement would primarily
						target destination slots, though additional interactions such as mouse scrolling
						or L1-R1 slot switching would also be supported, behaving similarly to
						<code>addToCarrier</code> operations. If slots are storage-based, stacks would
						persist on exit without being automatically dropped. The code structure of
						<code>RepairBench</code> is actually neat, and there could be slots stored in
						the entity.
					</p>
				</content>
			</section>
			<section title="Inventory and Item Management">
				<content>
					<p>
						The inventory system, while well-structured, should be moved to a distinct
						package separate from <code>item</code>. If inventories incorporate slots,
						they would use mapped slot structures instead of generic lists, potentially
						featuring distinct slot sets per storage unit. To support stacking, item
						metadata excluding quantity must remain consistent, ensuring compatibility
						with a slot-count-driven inventory model. If slots originate from underlying
						storage mechanisms, primary inventory capacities would be derived from these
						foundational quantity limits.
					</p>
					<p>
						Item picking functionalities should be generalized for all mobs using
						inventory slots.
					</p>
					<p>
						Item stacks would be managed through an inventory provider responsible for
						constructing inventories and item managers. Item configurations would align
						with provider specifications, including stacking criteria and limitations.
						Consequently, stack size would not be hardcoded within individual items or
						stacks. While items themselves would not be cloned, stacks should retain this
						capability. Item depletion should be validated upon each interaction, invoking
						the inventory manager listener upon stack modifications. Interaction methods
						should return <code>true</code> upon successful interactions, potentially
						reflecting state changes accordingly.
					</p>
					<p>
						The <code>RewardChestInventory</code> could be generalized to a class next
						to the <code>UnlimitedInventory</code>.
					</p>
				</content>
			</section>
			<section title="Recipe System and Resource Handling">
				<content>
					<p>
						The recipe system should be relocated into a separate package. Recipe
						instantiation should originally be handled through constructors or factory
						methods, eliminating the need for string parsing during initialization. Direct
						instance referencing should be used instead of strings or names, ensuring
						efficiency and reliability. Recipes must be unlocked prior to usage,
						maintaining integration with the advancement system.
					</p>
					<p>
						The main recipe processing method should be replaced with script-based
						execution. However, due to the inherent complexity of scripts, their
						implementation must align with standardized execution environments rather
						than directly mirroring the core code structure. Recipes should be treated
						as resources rather than being hardcoded within the system.
					</p>
				</content>
			</section>
			<section title="Miscellaneous Message Displaying Screens">
				<content>
					<p>
						The <code>InfoDisplay</code> would be removed, with statistics integrated
						into the pause menu. Each player would maintain their own set of statistics,
						as a part of the server or world data, but not as a unit of server or world,
						although it is still possible to have server or world statistics. World-related
						information may not be presented here but could be displayed elsewhere as needed.
					</p>
					<p>
						The <code>MessageDisplay</code> class serves only two purposes: displaying link
						error messages and resource pack descriptions. The former should be replaced
						with standard application notifications, while the latter could be merged into
						the main menu layout or incorporated via tooltips. As a result, this class
						would become obsolete and should be deprecated.
					</p>
					<p>
						The <code>TempDisplay</code> component offers little functionality. When
						opening an Internet address in a browser, a confirmation popup should always be
						displayed, but there is no need to automatically close the screen indicating the
						browser action. Instead, only the confirmation popup should close immediately.
					</p>
				</content>
			</section>
			<section title="Popup Management and Option Dialogs">
				<content>
					<p>
						Several functionalities currently handled by <code>PopupDisplay</code> could
						be streamlined through tooltips or full-canvas options menus. Submenus with
						limited components may be implemented as simplified panes, akin to anonymous
						classes, possibly replacing this class. Popups containing only informational
						messages could transition into notifications, while those featuring basic
						button options could be refactored into a dedicated class, such as
						<code>OptionMenu</code>. This structure would consist of a display message
						alongside defined options with names and fallback settings.
					</p>
					<p>
						Confirmation popups for quitting may not be necessary. Options dialogs that
						do not exit or transition screens could be full-canvas, while those requiring
						menu changes could incorporate a frame. Full-canvas screens would feature a
						lightly dimmed and blurred background or a dedicated background image,
						complementing the components. When listening for key sequences in the settings
						menu, a non-full-canvas banner would display active key inputs, ensuring
						clarity before any key is released. For instance, the confirmation dialog
						menu for resetting key bindings would include a frame, with its style
						determined later.
					</p>
					<p>
						Buttons should not rely on hotkeys, and this structure should be removed
						entirely, even for Keyboard-Only controls, with a simplified set of selectable
						options. Additionally, screen resolution may be leveraged for better
						horizontal arrangement of options, improving usability. Selection entries
						or button would provide a more intuitive alternative to direct key-listening
						mechanisms. The options dialog menu would not support <kbd>Esc</kbd> for
						exiting; users must choose an available option instead. The OSK would not
						require specific handling within this system.
					</p>
				</content>
			</section>
			<section title="Entity System and Interaction Model">
				<content>
					<p>
						The player entity is categorized as a living entity, distinct from mobs due
						to its unique control implementation. The primary distinction lies in the
						control system, allowing entity behaviors to be generalized without requiring
						excessive subclassing or repetitive implementations. Since player <i>take</i>
						action would be governed by specific abilities, such functionality should not
						be integrated into general entities. A revised classification of entity types
						will be proposed at a later stage.
					</p>
					<p>
						Entity interactions follow structured event-based processing:
						<list>
							<li>
								<b>Actors</b> initiate actions on targets, which receive those actions
								as events
							</li>
							<li>
								<b>Targets</b> represent entities affected by an actor's interaction
							</li>
							<li>
								<b>Controllers</b> regulate entity behavior based on triggered events,
								with multiple controllers potentially managing a single entity
							</li>
							<li>
								<b>Events</b> dictate method execution within the code
							</li>
							<li>
								<b>Global states</b> refer to the collective conditions across the
								entire world
							</li>
						</list>
					</p>
					<p>
						All actions are event-driven, meaning that interactions occur only when events
						are emitted and processed. This includes regular ticking events and discrete updates.
						Unlike spontaneous occurrences of attacking or using, entities operate through
						receiver interfaces responsible for damage and usage handling. When a mob or entity
						initiates an attack or use event against a target, this event is registered within
						the main event, forming a hierarchical structure of linked actions. Passive
						consequences stemming from primary events leverage their provided parameters
						alongside commonly observed global states.
					</p>
					<p>
						Attack events initiated by controllers should be structured efficiently. They must
						focus solely on responding to the primary event with predefined arguments and
						contextual global states. Attack initialization should remain minimal, calculating
						only the foundational aspects of an attack, while relevant parameters should be
						assigned by the controller. The main entity structure should not directly manage
						event responses. Attack actions may instead be managed through independent
						controllers, with the corresponding attack response solely processing the event
						rather than managing indirect state changes by the event. Thus, only the damage
						reception interface should reside within an entity's main structure.
					</p>
					<p>
						Similarly, use interactions require clarification. Events related to "use" actions
						may involve tiles or entities as subjects, while "used on" events primarily concern
						items as subjects. The subject may shift based on the specific event type, but by
						default, the target would be the subject. Until a refined solution resolves this
						ambiguity, usage actions should not be split into separate categories. Using the
						middle mouse button may provide an alternative interaction mechanism, with further
						details subject to future discussion.
					</p>
				</content>
			</section>
			<section title="Mob Intelligence and Damage Handling">
				<content>
					<p>
						Movement capabilities, including swimming and traversal across surfaces, would be
						dictated by AI-driven mov controls, ensuring proper contextual application.
						Additionally, the "on fire" visual effect would be treated as a transient metadata
						attribute, with entities retaining the ability to reject such properties upon
						assignment. Fire and burn damage would be processed through the damage source,
						acting as an argument within the damage-handling system. For the controls, there
						might be a method that even mods could add by the interface with the default values;
						this may require Typed Anchor Dynamic Mapping, which will be proposed later.
					</p>
					<p>
						Damage evaluation would be managed by controls, eliminating redundant checks such
						as <code>isAttackable</code>. Since entities block interactions regardless of their
						nature, preliminary validation steps should be omitted, allowing actions to proceed
						without additional verification layers. Similar simplifications also apply to
						<code>isInvulnerableTo</code> and <code>isUsable</code>, reducing inconsistencies
						and streamlining API usage.
					</p>
					<p>
						Interactive box sizing would be adjusted with greater precision, rather than
						relying on approximate sprite dimensions. The current implementation using
						<code>tickTime</code> would be deprecated. Temporary timers for event-driven
						effects, such as burning damage, would be pooled within dedicated tick-based
						handlers per entity, minimizing unnecessary class-level bloat while retaining
						separation of responsibilities. Death detection would reside within health-related
						systems, while speed modifications would be managed via move controls,
						particularly when factoring in speed-altering effects.
					</p>
					<p>
						The <code>MobAi</code> subclass would be dismantled, with individual components
						such as despawning mechanisms, intelligent behaviors, automation logic, rendering,
						and loot processing transferred to specialized controls and handlers.
					</p>
					<p>
						For <code>EnemyMob</code>, behavioral intelligence would be dictated by control
						mechanisms. The tracking system requires refinement to enhance targeting efficiency.
						The attack range should extend beyond direct physical contact, ensuring broader
						interaction capacity. All attack-related methods should be consolidated into a
						single function, accepting a damage source parameter for streamlined execution.
					</p>
				</content>
			</section>
			<section title="Player-Specific Considerations">
				<content>
					<p>
						Several exposed fields in <code>Player</code> would be concealed behind dedicated
						handlers, including delay counters and GUI-related elements, which would not
						reside within a general mob class. Potion effects would be managed via
						specialized control structures. Tile condition validation for event handling
						should be processed within tile logic rather than mob systems unless explicitly
						tied to mob behaviors.
					</p>
					<p>
						Target selection for interactions should prioritize proximity-based
						identification. If no valid target is within range, no interaction should be
						initiated. Cursor-based selection should allow for enhanced precision. If an
						entity obstructs selection within the active range, the tile beneath should
						not be selectable, even the entity gives no interaction.
					</p>
				</content>
			</section>
			<section title="Damage System and Tile Interaction">
				<content>
					<p>
						The <code>DamageSource</code> class should incorporate an argument inferred
						from <code>DamageType</code>. The argument would support multiple data
						structures applicable across different scenarios. <code>DamageType</code>
						would transition into a standard class rather than an enumerated type to
						facilitate extensibility and improve interface accessibility.
					</p>
					<p>
						Tile interactions, including effects triggered upon stepping or collision,
						would be processed through predefined standard methods within tile classes.
						If interactions require continuous updates, associated tile entities would
						be returned. Factory methods such as <code>onTileSet</code> should be
						contained within relevant initialization scopes where tiles are set and
						defined. Additional configurations would be determined by tile properties.
					</p>
					<p>
						Fluid tiles would be categorized separately, incorporating dedicated fluid
						mechanisms. Tile connection-based texture rendering should be exclusively
						handled within texture definitions rather than within tile logic. Tile
						destruction callbacks, such as those triggered by mining or explosions,
						would follow a standardized method structure, accepting destruction sources
						or types as parameters.
					</p>
					<p>
						Finally, <code>getData</code> methods in tile implementations would be
						eliminated, as relevant data would be processed through chunk or tile managers.
					</p>
				</content>
			</section>
			<section title="Furniture and Tile System">
				<content>
					<p>
						The movement mechanisms for <code>Furniture</code> would be reconsidered in
						light of the decimal coordinate system. Lightweight objects may remain entities,
						whereas heavier objects, such as <code>Furnace</code> and <code>Oven</code>,
						would transition into tile-based structures. Additionally, item sprites should
						not be stored within entity instances, ensuring separation of visual assets from
						entity logic. The use of reflection for copying remains fragile and should be
						avoided.
					</p>
					<p>
						The inclusion of a <code>die</code> function within furniture structures is
						conceptually awkward and should be restructured.
					</p>
					<p>
						Furniture item implementation should align with furniture mechanisms. If all
						furniture can be held, players might be able to pick them up using bare hands
						or a specialized item. However, selectively allowing only certain furniture
						items to be held would introduce inconsistencies. If furniture items associate
						data via properties, a corresponding resource key must be registered explicitly,
						rather than through dynamic registration. Furthermore, furniture without item
						representations should remain unregistered for its item form unless explicitly
						required. As a result, not all furniture may be freely accessible to players.
					</p>
					<p>
						The <code>PowerGloveItem</code> currently serves as a placeholder for furniture
						pickup. Its removal or revision should be determined based on future inventory
						system developments.
					</p>
				</content>
			</section>
			<section title="Tile Management and Placement Behavior">
				<content>
					<p>
						The <code>TileItem</code> class would persist, maintaining its function as the
						intermediary for direct tile placement. However, the approach depends on broader
						decisions regarding tile mechanics. Tiles could transition into items reserved
						for creative mode, facilitating expedited placements. <code>TileModel</code>
						would act as a default data structure rather than preserving original tile data,
						as stacked tiles do not require retained tile data. If tiles lack item-based
						representations, an item type containing a single resource key with metadata
						encapsulating tile attributes would be introduced. The primary determinant for
						placement eligibility would be the tile type.
					</p>
				</content>
			</section>
			<section title="Tile Classification and Logical Consistency">
				<content>
					<p>
						If <code>TorchTile</code> remains an item that can be picked up, classifying it
						as furniture may be more appropriate. Furniture is inherently designed for
						mobility, allowing players to relocate lightweight objects easily, whereas tiles
						are fixed structural components. This misalignment in mechanisms creates
						inconsistencies in both logical behavior and expected interactions. Additionally,
						small decorative tiles such as wall-mounted torches would be designed explicitly
						for placement on wall tiles, reinforcing logical coherence within the system.
					</p>
				</content>
			</section>
			<section title="Inventory Drop Handling">
				<content>
					<p>
						The mechanisms governing item drops upon player death remain undecided, with
						various implementation approaches offering distinct properties. Ultimately,
						the chosen method would align with the game's thematic direction. If the
						design philosophy prioritizes realism, the system may resemble Rust, where a
						fallen player's body retains inventory items. In such a case, the
						<code>DeathChest</code> concept would become unnecessary.
					</p>
				</content>
			</section>
			<section title="Loot System">
				<content>
					<p>
						Inventory randomization should be managed within generation-handling systems
						rather than being embedded in <code>Chest</code>. Container inventories should
						remain publicly accessible as standardized public interfaces. Since dungeon
						mechanisms are no longer relevant, previous implementations can be disregarded
						despite potential improvements.
					</p>
					<p>
						Tile loot drops may be regulated via tile properties. Damage multipliers
						could be controlled through game rules, ensuring they affect players in
						appropriate scenarios. The concept of automatic damage revival lacks logical
						coherence, particularly for tiles without health attributes, as they are
						primarily influenced by interactions such as mining.
					</p>
					<p>
						Resource tiles like <code>OreTile</code> and other rock formations would
						yield loot upon each mining action or complete destruction. Their visual
						design would avoid exaggerated spiky appearances, adhering to a more
						natural aesthetic.
					</p>
				</content>
			</section>
			<section title="World System and Dimension Management">
				<content>
					<p>
						The <code>World</code> class should be instantiated independently rather
						than residing within <code>core</code>. Additionally, level management should
						be delegated to world instances rather than being handled by unrelated classes.
						Several generator configurations, including dimensions, would be defined
						within assets rather than hardcoded into the program. World settings such as
						the seed and world name would be encapsulated within a dedicated configuration
						object.
					</p>
					<p>
						All world-related randomization processes should be specific to instances
						and potentially replaceable by the backend engine as needed. Certain fields,
						such as the level change listener, last world entry and exit timestamps, lack
						practical utility. Dimension transitions should be governed by actual
						implementations rather than relying on an unused listener. Moreover, tracking
						entry and exit times through direct comparisons are unnecessary when
						initialization and termination can be managed via instance creation and
						destruction. The approach of resetting sprite animations within these processes
						is flawed; sprite animations should instead be handled separately. Maintaining
						instances remains more effective than invoking <code>resetGame</code>.
						Additionally, the logic involving <code>Player#respawn</code> and
						<code>Level#add</code> within the same block introduces unnecessary complexity;
						a more semantic and logically structured code approach should be adopted. While
						<code>WorldSettings</code> aligns conceptually with this logic, the broader
						implementation still requires improvement.
					</p>
					<p>
						Under the new entity system, an entity cannot simply be removed from a dimension;
						it must be eliminated entirely. However, entities may transition to a different
						dimension by modifying coordinates, ensuring no null entries. The
						<code>getClosestPlayer</code> function should be maintained as a general-purpose
						helper method, accessible across various processes including commands. Other
						relevant methods may also be retained.
					</p>
					<p>
						The execution of world events, activities, and commands must be carefully
						evaluated to avoid bypassing critical processes. Improper handling could lead
						to unintended execution omissions. This includes aspects such as teleportation
						across dimensions; all necessary unprocessed events should be considered.
					</p>
				</content>
			</section>
			<section title="Difference in Tile System">
				<content>
					<p>
						There would be several differences due to the new tile system to be proposed.
					</p>
					<p>
						<code>FenceTile</code> serves merely as an overlay for ground tiles, but
						the simplified tile system resulted in verbose code that should be optimized.
					</p>
					<p>
						Since <code>HoleTile</code> lacks functional significance, it would be removed.
						Instead, an "air tile" designation would be introduced, also applicable to
						<code>InfiniteFallTile</code>.
					</p>
					<p>
						Both <code>DirtTile</code> and <code>SandTile</code> would require foundational
						support. In the absence of underlying tiles or in cases where only air tiles are
						present, these tiles would collapse. Additionally, footsteps on such tiles would
						generate extra dust particle effects.
					</p>
					<p>
						Since the conventional depth-based <i>level</i> system would be retired in
						favor of independent dimensions with no direct geographical continuity,
						<code>StairsTile</code> would be deprecated. However, stair-like tiles
						could still be incorporated as mobility aids for mobs. These tiles could be
						composed of various materials and may exist as fragments or incomplete sections.
					</p>
				</content>
			</section>
			<section title="Chunk-Based Dimension System">
				<content>
					<p>
						The original fixed-size level structure would evolve into an unlimited world
						consisting of chunk-based dimensions. Given that world generation would be no
						longer constrained by predefined size limitations, structure generation would
						operate independently of world size constraints. Each dimension would retain
						a display name and receive a seed derived from the overarching world seed but
						would not possess specific size parameters. Even if the generator produces a
						finite world size, additional chunks should remain accessible, albeit empty.
					</p>
					<p>
						During dimension construction, essential metadata including mob count limits,
						would be defined. Entity container management would be confined within dimensions
						and chunks, overseeing entity counts, additions, removals, and transfers.
						Server-side entity queues for additions and removals would use linked lists
						within the entity manager. Chunk-level entity managers may be synchronized
						with dimension-level managers, ensuring consistency across modifications.
						Entities might be organized within a quadtree structure to facilitate efficient
						chunk management.
					</p>
					<p>
						As part of the proposed world system rework, depth indices for dimensions would
						be eliminated. The notion of "levels" would be discarded in favor of a pure
						dimension-based structure. The concept of "level" does not currently exist
						within the revised framework.
					</p>
				</content>
			</section>
			<section title="Entity Indexing and Searching Mechanisms">
				<content>
					<p>
						Entities would be stored across two distinct mappings. Each chunk would
						manage its entities using either a quadtree or k-d tree structure. Dimensions
						would oversee all loaded chunks, featuring an indexing mechanism for querying
						entities within chunks. The world would handle all loaded dimensions,
						implementing an indexing system for querying entities across dimensions while
						maintaining a global map that associates entity classes with collections of
						entities.
					</p>
					<p>
						For nearest-entity searches within a specified range, only selected chunks
						would be considered. Nearest-neighbor search algorithms would be employed,
						or entities would be filtered by type using a mapped collection before looping
						through results. Additionally, when selecting all entities within a given range,
						including those positioned atop a tile, temporary geometries in the physics
						engine may be used to identify collided objects rather than exclusively relying
						on centers of entities.
					</p>
				</content>
			</section>
			<section title="Game Time Management and Ticking System">
				<content>
					<p>
						The in-game ticks per second (TPS) would be adjusted to 20 instead of 60.
						Additionally, the length of a full-day cycle would be set to 20 minutes
						rather than 18, ensuring a reasonable duration while maintaining alignment
						with 60-minute mechanism. To preserve performance consistency, the game
						speed should remain constant and may not be subject to pausing. Several
						fields would be introduced for tracking game time values:
						<list>
							<li>
								<code>dayTime</code>: Represents the total number of ticks (time) elapsed
								during a single game day
							</li>
							<li>
								<code>dayCount</code>: Tracks the number of days that have passed within
								the game world
							</li>
							<li>
								<code>gameTime</code>: Records the cumulative ticks (time) elapsed
								throughout gameplay
							</li>
						</list>
						A backup routine may be implemented to replace auto-saving, requiring a
						temporary suspension of game ticking for data synchronization. However,
						this would not constitute an actual pause in gameplay.
					</p>
					<p>
						Time enums representing different phases of the day may not follow uniform
						quarter divisions, particularly since "0" would correspond to either midnight
						or midday. Seasonal cycles and variable day lengths may be introduced in
						future updates, requiring definitive constants to define distinct time phases.
						Minecraft's approach could serve as a reference, though its daytime ticking
						structure does not strictly conform to real-world time conventions for "0".
						Further implementation details would be discussed and finalized later.
					</p>
				</content>
			</section>
			<section title="Entity Ticking and UI Separation">
				<content>
					<p>
						Player entity ticking should be entirely independent of UI ticking, as
						entities exist within the world system, whereas UI elements function solely
						on the client side. Current implementations may handle menu interactions
						within entity ticking functions, which is impractical. Instead, such
						operations should be delegated to the <code>MenuManager</code> or a similar
						management class, ensuring proper class isolation and separation of
						responsibilities.
					</p>
				</content>
			</section>
			<section title="Sleeping Mechanisms">
				<content>
					<p>
						With the introduction of the new sleeping mechanisms, tracking sleeping
						player counts would no longer be necessary. Additionally, <code>Bed</code>
						instances would not store color enums; item, entity, and tile display names
						managed via translation keys and registry keys rather than defined within
						constructors. Removing the player entity from the level upon sleeping is an
						illogical design choice and should be revised accordingly.
					</p>
					<p>
						Future sleeping mechanisms would be reconsidered to maintain consistent game
						speed and ensure continuous events are not disrupted by time-skipping or
						acceleration. However, extended nighttime durations may be problematic under
						certain circumstances. To mitigate this, an alternate <i>dream world</i>
						dimension could be introduced during sleep, functioning as a single-player
						environment. If a player sustains significant damage or dies within this
						dimension, they would instantly wake up in bed. Correspondingly, a biological
						health system would be developed to integrate this mechanism.
					</p>
					<p>
						Players would be able to sleep at any time, provided their character reaches
						a fatigue threshold. This approach allows gameplay to continue seamlessly
						while preserving in-game consistency. Detailed implementation specifics would
						be determined later. Additionally, this method avoids performance inefficiencies
						that could arise from artificially accelerating game ticks.
					</p>
				</content>
			</section>
			<section title="Ticking Order and Parallel Processing">
				<content>
					<p>
						The sequence in which tick events are executed within a world is crucial. Since
						tick events can affect entity positions and even their existence, entity
						existence-related events should be processed at the end of a ticking cycle.
						Furthermore, players include both local and remote participants, meaning tick
						operations must rely on signal transmissions while maintaining synchronized
						entity management. All entities, including their controls and existence states,
						should be processed simultaneously to ensure consistency.
					</p>
					<p>
						Chunk managers would refresh entity positions according to updated coordinates,
						following structured stages for optimized management. If parallel processing
						of entities is introduced, tick-dependent events should be segregated and
						queued instead of being executed immediately, allowing for accurate state
						synchronization.
					</p>
				</content>
			</section>
			<section title="Client and Server System Considerations">
				<content>
					<p>
						Users would be assigned unique client IDs, though detailed implementation
						specifics are yet to be determined.
					</p>
					<p>
						The server architecture requires comprehensive planning, encompassing
						serialization, routing, and network communication. Safeguards must be
						implemented to mitigate non-synchronization issues and data loss. For
						consistency and compatibility, there should be no fundamental distinction
						in implementation between single-player and multiplayer, particularly
						within the server-client framework. Transmission data may be identified
						using numeric IDs, though the protocol would not support forward or
						backward compatibility.
					</p>
				</content>
			</section>
			<section title="Server Analytics and Data Collection">
				<content>
					<p>
						Server-side analytics could track active clients based on Launcher activity
						and periodic pings, similar to Minicraft+. However, this process should not
						be classified as general telemetry, which collects device information and
						usage reports. Data collection must occur <i>only with user consent</i>, and users
						should retain the ability to enable or disable tracking via preferences after
						the initial launch (as identified by local save data).
					</p>
					<p>
						Both data collection methods are entirely optional, with accompanying user
						agreements and terms. Server-side counting would be managed via database
						records, whereas pings would remain anonymous. Descriptive telemetry and automatic
						crash reporting, however, may not be anonymous, as they could include device
						details or account identifiers. Implementation specifics are yet to be finalized,
						but they represent an important consideration.
					</p>
				</content>
			</section>
			<section title="Multiplayer Management and Account System">
				<content>
					<p>
						The <code>MultiplayerDisplay</code> offered little meaningful reference.
						However, login authentication should be managed by the Launcher, with
						client ID, user ID, authorization token, and session ID transmitted via
						launch arguments. Additional data may be retrieved by the application
						based on these parameters.
					</p>
					<p>
						Since skins would be managed by the platform’s account system, they should
						<i>not</i> be processed within the application. Consequently, there would be no
						in-game preview or customization screen for skins. Instead, skin data would
						be transmitted <i>only</i> from the server to the client, where local comparison
						would occur. The watcher thread for skin tracking would no longer be
						necessary. The Mob Sprite handling process would differ significantly under
						this structure.
					</p>
					<p>
						Client IDs would rely on <i>Universally Unique IDs</i> (UUIDs) <i>with specialized
						modifications</i>. On the server side, all client IDs would be recorded and
						associated with account IDs. Account IDs, unique UUIDs maintained by the server
						database, would serve as <i>server player entity IDs</i> (EIDs). These EIDs would
						be distinct within the server or world, appended with identifiers differentiating
						players from other entities.
					</p>
					<p>
						Client IDs would remain unique, permitting multiple Launcher instances across
						various client devices. However, two clients <i>cannot</i> connect to the same
						server using identical client IDs, if attempted, a new client ID would be
						generated. Additionally, multiple clients <i>cannot</i> access the same server
						under a single account.
					</p>
					<p>
						In <i>single-player mode</i>, offline gameplay would be supported via a default
						hardcoded player EID, mapped to account IDs to facilitate <i>guest modes</i>
						without requiring an account. Although guest mode simplifies implementation,
						maintaining a system where account-based player EIDs are universally used
						ensures that server worlds remain playable offline. These safeguards assumed
						ideal data integrity, with unauthorized modifications ignored.
					</p>
					<p>
						While EIDs are not strictly <i>network-related</i>, they were originally
						categorized under <code>Network</code>. Instead, they should be reorganized
						into utility functions or a dedicated classification.
					</p>
					<p>
						Client synchronization decisions would be dictated by the <i>server</i>,
						meaning any invalid player actions could be <i>ignored</i> or <i>reversed</i>
						at the server’s discretion.
					</p>
				</content>
			</section>
			<section title="Pause Menu and Player Death Screen">
				<content>
					<p>
						The pause menu structure would introduce <code>SingleplayerPauseScreen</code>
						and <code>MultiplayerPauseScreen</code>, with respective versions allocated
						based on game mode. Single-player sessions and LAN hosts would use the
						single-player version, whereas multiplayer participants would engage the
						multiplayer variant. The menu title would be "Game Menu", featuring:
						<list>
							<li>
								<b>Universal options</b>: "Back to Game", "Settings", "Statistics"
								and "Advancements"
							</li>
							<li>
								<b>Singleplayer exclusive options</b>: "Open to LAN", "World Options"
								and "Save and Quit"
							</li>
							<li>
								<b>Multiplayer exclusive options</b>: "Disconnect", with additional
								functionalities extendable via plugins or mods
							</li>
						</list>
						A potential "Save" or "Backup" option for single-player remains undecided.
						Implementing these features via commands would be simpler, though both actions
						require suspending gameplay for synchronized data storage. Game saving and
						backups should occur only when all server-side ticking threads are suspended,
						rendering them internal server operations rather than in-game commands.
					</p>
					<p>
						Dedicated servers have predefined server commands, whereas single-player mode
						lacks such functionality. The scope of in-game commands is subject to future
						discussion. The most possible implementation method would be within the pause
						menu, pending further review.
					</p>
					<p>
						The background of the pause menu would display a dimmed gameplay screen, which
						would remain interactive in terms of rendering but not input, clicking the
						dimmed screen would <i>not</i> close the menu.
					</p>
					<p>
						The <code>PlayerDeathDisplay</code> would transition into
						<code>PlayerDeathScreen</code>, visually similar to the pause menu but with
						the gameplay screen <i>frozen</i> at the last frame before death. The header
						"<i>You Died!</i>" would accompany the death message. Upon death, the player
						entity ceases to exist in the world, yet the player remains present, albeit
						in an unspawned state, preventing any interaction with world events.
					</p>
					<p>
						At this stage, the player may either <i>respawn</i> or <i>quit</i>, with the
						world continuing to function normally. If <i>instant respawn</i> is enabled,
						the death screen would be bypassed, and the player would respawn immediately.
						The quit button functions identically to its counterpart in the pause menu.
						No additional menus or information would be accessible during this screen.
					</p>
				</content>
			</section>
			<section title="Save System and World Loading Management">
				<content>
					<p>
						A <code>SaveManager</code> or equivalent class would assume the upper-level
						functionalities previously managed by <code>FileHandler</code>. Basic file
						helper functions, such as folder deletion and copying, are already available
						in Kotlin through <code>Path.deleteRecursively</code> and
						<code>File.copyRecursively</code>, eliminating the need for additional
						implementations. Future asset management should not rely on filesystem-based
						listing, as an advanced asset system would be expected to replace this approach.
					</p>
					<p>
						World loading would be optimized to provide a structured and visually informative
						process. For instance, loading sessions should incorporate progress bars for
						both asset loading and world loading. Since resource loading logic operates
						outside menus, the interface operations should reside within a dedicated
						loading menu rather than the actual loading operations being embedded in the
						interface elements. The loading screen should be instantiated alongside the
						loading session, dynamically updating and refreshing progress as resources are
						processed. Additionally, logging world names is redundant when proper class
						structure organization provides sufficient clarity. Resetting the world before
						initialization is unnecessary when instances are properly instantiated; once
						loaded, reset values should be disregarded.
					</p>
					<p>
						The exceptions encountered during world loading are generally justified, as
						rare failures require immediate termination or cancellation of the process.
						While existing code structures may be somewhat disorganized, the fundamental
						approach remains practical.
					</p>
					<p>
						The save and load system should operate as independent components rather than
						existing as direct <code>Save</code> and <code>Load</code> classes. Each aspect,
						including timing, system handling, and individual responsibilities, should be
						distinctly isolated. Preference management should remain autonomous, with no
						direct association with world save data.
					</p>
					<p>
						If a loader fails to locate the intended object, an explicit error should be
						generated, signaling the absence of the requested resource. As a result, unknown
						objects <i>should not</i> be loaded. The <code>UnknownItem</code> class should
						be deprecated for consistency. Additionally, strict mode should <i>always</i>
						enforce immediate loading termination upon encountering errors.
					</p>
				</content>
			</section>
			<section title="Level Transition and Loading Screen">
				<content>
					<p>
						The <code>LevelTransitionDisplay</code> should function purely as a UI component,
						delegating the actual dimension transition process to a dedicated manager. Since
						precise progress tracking may not always be possible, the loading screen should
						display a standard background alongside status messages. Moreover, dimensions
						might not be preloaded in advance; at a minimum, the target chunk must be fully
						generated before transition completion.
					</p>
					<p>
						The <code>LoadingDisplay</code> would be renamed as<code>WorldLoadingScreen</code>,
						preventing users from bypassing it via the escape key. Given that world loading
						occurs chunk by chunk, progress tracking would be segmented accordingly,
						reflecting the individual status of each chunk. Corrupted chunks and regions
						should be regenerated, with automatic backups created before deletion from the
						loaded pool. Missing spawn-area chunks should be dynamically generated and
						monitored by <code>WorldCreatingScreen</code>, which would also handle new world
						creation via <code>WorldCreateScreen</code>. The existing
						<code>LoadingDisplay</code> implementation was somewhat disorderly. Loading
						operations should be managed by a dedicated <i>manager class</i>, ensuring
						exception handling is properly delegated to menu-driven dialogs rather than the
						loading screen itself.
					</p>
					<p>
						Automatic data fixing would occur within structured loading schemas, assuming
						previously reported and resolved issues. Instead of menu-based message popups,
						application notifications would relay relevant alerts. Progress would be
						handled specially.
					</p>
				</content>
			</section>
			<section title="Compatibility with Legacy Save Formats">
				<content>
					<p>
						Both <code>LegacyLoad</code> and <code>HistoricLoad</code> were introduced
						to maintain compatibility with older world save formats. Initially,
						<code>LegacyLoad</code> facilitated handling of old save data, whereas
						<code>HistoricLoad</code> was subsequently introduced to distinguish
						between the period when version tracking was not originally considered and the
						time when versioning became included among old versions. Significant structural
						shifts following the legacy phase warranted this separation.
					</p>
					<p>
						Additionally, <code>HistoricLoad</code> introduced a stricter conditional checking
						methodology in the codebase, moving away from previous implementations that relied
						predominantly on the simple if-else statements and switch-case logics. This change
						was driven by the reliance on text-based comma-separated values (CSV) format, which
						required extensive string parsing, while the following approach of using JavaScript
						Object Notation (JSON) also conforms to this. By using this approach, potential
						errors could be minimized while maintaining essential support for older saves.
					</p>
				</content>
			</section>
			<section title="Schema-Based Save System">
				<content>
					<p>
						Future iterations of the save system would adhere to <i>a schema-driven
						framework</i>, ensuring robust backward compatibility. This approach would
						enable progressive fixes for outdated saves, applying predefined schemas that
						gradually improve structural integrity. These data fixers should be <i>static
						and immutable</i>, implemented as singletons within the codebase. Exception
						management would incorporate contextual detail, offering <i>different
						behaviors</i> based on operational mode:
						<list>
							<li>
								<b>Compatible mode</b> permits special accommodations for older
								formats and corrupted data.
							</li>
							<li>
								<b>Strict mode</b> enforces immediate failure upon encountering
								inconsistencies.
							</li>
						</list>
						There is a potential possibility for recovery mode for corrupted data,
						but such functionality may be provided by the Launcher instead of game.
						File parsing and format handling would reside within low-level components,
						particularly when processing custom serialization formats. Where applicable,
						Java Virtual Machine (JVM) objects would be instantiated in Rust parts via
						parsed Rust objects, though <i>preference settings may remain exempt</i>
						from this approach. Serialization functionalities may also be integrated
						systematically.
					</p>
					<p>
						Save operations should be independently structured rather than housed within
						a unified <code>Save</code> class. Serialization would be <i>modular</i>,
						tailored to different data objects such as entities, ensuring all dynamic tags
						are properly processed during save operations. A dedicated <code>WorldSave</code>
						class would be introduced to oversee world-specific save data, facilitating
						logical and structural serialization processes. Preference settings could
						use <i>general serialization</i>, given their inherent key-value structure.
						The Rust component would oversee encoding of serialized objects into save files.
					</p>
					<p>
						It is important to distinguish <i>save versioning</i> from <i>game or public
						interface versions</i>. Instead of aligning with standard game updates, world saves
						would be tracked through an independent version number, incremented sequentially
						for identification.
					</p>
				</content>
			</section>
			<section title="Basic Code Structures">
				<content>
					<p> =01=
						<code>Action</code> in Kotlin could be instead a typealias of function type
						<code>() -> Unit</code>, and declared in utils. It is the similar as
						<code>Condition</code>, which could instead be <code>() -> Boolean</code>
						or a functional interface with advanced features. However,
						<code>MonoCondition</code> could be replaced by <code>Predicate</code>.
					</p>
					<p> =03=
						No class would extend the major game class <code>TerraModulus</code>. The
						<code>RenderSystem</code> would only handle the top operations. UI components would
						be handled in another manager, like <code>UIManager</code> or <code>MenuManager</code>.
						The sprite management would be merged into the registry system. Everything would be
						enhanceable by hardware accelerations, so the rendering system would highly depend on
						the native libraries and the APIs, especially physics. Detailed implementation of
						graphics and physics would be discussed later. The major render system would manage
						the states of the world renderer, so the systems of UI and world graphics are
						separated. This way, several fields would be separated. Also, the window size
						would not be fixed, and there would not be something called the canvas "scale",
						but there would be UI "scale", which is a simple multiple of the base dimensions,
						available for setting depending on the window size (not saved). The entire render
						system would be backed by the rendering engine.
					</p>
					<p> =03=
						The canvas would be fully filled. The several UI elements like the app status bar
						and HUD elements (e.g. hot bar, boss bar, debug screen) would become menu components.
						Level rendering would be a part of world rendering, which includes world background
						and sky rendering.
					</p>
					<p> =05=
						Toasts are usable, but not the notification text directly on
						screen. All notifications would be replaced by chat (in game for world events) or
						toasts (any client event in game). The toasts would have their own lifetime.
					</p>
					<p> =03=
						Fullscreen and screenshots would be handled instead by the render system.
					</p>
					<p> =05=
						The usages of toasts are not in the same level. <code>AppToast</code> is a subclass
						of <code>Toast</code>, but it is used in the same level as the superclass by the
						fields. They should either be separate classes or subclasses, or even in the same
						system. It depends on actually how they would be implemented. The behaviors of the
						toasts may be different by this, so it could not be said in simple words just now.
					</p>
					<p> =16=
						Resources or assets would not be loaded early as before canvas initialization, but packs would be loaded
						at the same time as vanilla assets.
					</p>
					<p> =03=
						However, probably only the loading screen, with
						probably a splash screen would be the hardcoded asset image embedded into the
						application. There would be a progress bar to initialize full loading of all parts
						after the appearance of the splash screen with a logo, like Minecraft's one, simple
						and neat but symbolic. Maybe there could be customized splash screen inserted after
						initialization just before the title screen or pre-, during or post-world loading.
						As for when to initialize tiles, entities and items, still a question, since it
						depends on how they are defined with registries later. For the title screen, it
						would be set only after the initialization, so the necessary resources would be
						ready first. If it is set to fullscreen on start, the window would be set to
						fullscreen when initialized, not that separated.
					</p>
					<p> =24=
						Colors, there is entirely no need to care about old-formatted color values. However,
						it could just use the similar functions, but there could be more colors, using less
						the tint function, or probably using other utility functions. For formatting codes,
						they would not be handled in <code>Color</code>, but another class handling display
						strings or whatever fits. In fact this kind of format may exist control characters
						that normally could not be typed, so they could not be used properly. The
						<code>limit</code> function is just the <code>clamp</code> function, repeated. The
						tinting functions and most other functions would likely be removed, but the lightness
						calculation could be reused, in somewhere.
					</p>
					<p> =01=
						<code>Dimension</code>, <code>Insets</code>, <code>Point</code> and
						<code>Rectangle</code> could be made into value classes, in which the fields should
						be immutable. Likely these classes related to graphics would be hidden into the
						graphics module, which would be only used by client side. There could be more
						functions to transform, operate or interact with these value classes. Also, Insets
						may not be really needed when there is <code>Dimension</code>, but probably the
						functions could be directly added to <code>Rectangle</code>.
					</p>
					<p> =01=
						If guessed correctly, <code>Ellipsis</code> is probably just the dotting animation.
						This style is mostly not used, since it is more tended to show more details and be
						more intuitive. Mostly, spinners, progress bars or more fancy animations are used
						nowadays. Ellipsis would not be used in the future. <code>SequentialEllipsis</code>
						seems to be moving a single dot per period; <code>SmoothEllipsis</code> seems to be
						looping dots like a loading progress bar without progress. The <code>DotUpdater</code>
						updating methods seem to be various but really unnecessary, it is still lacking
						information.
					</p>
					<p> =03=
						The <code>Font</code> class would be made into a single package but most likely just
						hidden within the graphics module. The <code>chars</code> would be fully configurable
						later by assets pack. Several drawing mode of text would be available, like plain,
						formatted, hard-/pre-formatted (styled). When drawing, an optional configuration
						object like the <code>FontStyle</code> could be passed as an argument, for background
						and foreground colors, and the rendering bounds? Actually for bounds, horizontal
						scrolling may be disused, but perhaps only the vertical values are useless. The
						ability to scroll entries horizontally would eventually not be implemented, but for
						displaying scrolling text only. Still, all the drawing modes could be combined to
						just set whether to enable formatting codes as the configuration attributes, since
						when nothing is set, it is fully plain; when something is set, it could be styled.
						The "redo" code may still be too complex in the system, so the stack class would not
						be needed. Width calculation, maybe using advanced looping, since invalid codes
						would not be used in formatting; probably display component architecture would be
						used to prevent this. Drawing centered may not be used anymore; drawing paragraphs
						would be quite advanced, so it would be higher level. For drawing styles, there
						could be paragraph alignment and shadows, but the current implementation of
						<code>FontStyle</code> is quite poor, and it could be replaced by using UI
						components.
					</p>
					<p> =09=
						Texture atlas could be implemented, especially when the engine is lower level, since
						it could improve memory efficiency for a mass number of sprites. All the textures
						would use the same set of atlases, in which a new one would be created only when
						the existing one(s) is/are full. However, a difficulty is that not all the sprites
						would be squares or even squares with the sides of powers of 2, a good algorithm
						would be required. A reference could be taken from
						<a href="https://www.david-colson.com/2020/03/10/exploring-rect-packing.html">
							this article
						</a>. Note that they would be mostly rectangles or squares, and all textures from
						all the assets packs would be loaded. <code>MinicraftImage</code> is just an
						alternative of the existing image classes with just a simpler class structure, but
						may not be used.
					</p>
					<p> =10=
						Darkness rendering would be advanced based on light sources and light level values
						saved in the chunk data. Rendering lightness would depend on the gamma value set.
						Mirroring settings could just be 2 separate boolean values, but sprite transforming
						would be realized in another way, probably by filtering function or something.
					</p>
					<p> =03=
						Anyway, the canvas would just handle the rendering results by the graphics elements
						from both the UI and the world. When it comes to the rendering engine, internally
						buffer arrays would be used. The rendering queues is quite a good idea compared to
						the idea in the past, it was used for rendering optimization. However, the optimization
						strategy by checking the clearing request is not that ideal in the system, since it
						could be an overhead. A better way is in fact to skip rendering when there is some
						places are intended to be hidden when it is in the rendering functions, but not by
						the processing functions of rendering requests. The responsibilities should be definite
						in fact. There would not be an overlay canvas just for rendering lights, but all the
						rendering would be done with just one canvas handled by the rendering engine for
						compositing all the graphics elements in one. The current way in <code>Screen</code>
						is actually more like a workaround to optimize graphics rendering, though not the
						best or the most practical in the industry. Among the rendering classes, only the
						sprite rendering and inverted color line rendering ones have not taken the advantages
						of <code>Graphics2D</code>, which could be optimized by hardware acceleration.
					</p>
					<p> =09=
						As for <code>Sprite</code>, there would probably be a high level wrapper of the
						low level sprite instances. When sprites are loaded into the centralized texture
						atlas, each sprite corresponds to a pointer with some information locating the
						entire sprite pixels in the atlas. Then the sprites are saved into the registries.
						So, <code>Px</code> would also be replaced by the OpenGL functionalities.
					</p>
					<p> =09=
						The <code>SpriteAnimation</code> should really be the animated instances of the
						sprites with just a pointer with some little extra data. However, it may either
						be the animated UI components, or the animated texture parts. The sprite
						architecture should be similar to the specification as in assets pack. Also,
						the implementation of it internally is too complex, there is no need to align
						with the time outside, but just a simple tick counter by the ticking function.
						The borders should not be done here, but in another level. If it is just a
						simple extended variable instances from a sprite, there is no need for this,
						all the instances would be recreated, so no "relinking" is needed. However,
						these may probably just be remade from zero as a better solution.
					</p>
					<p> =09=
						These are probably a lot of messes in the codebase. The <code>SpriteManager</code>
						should be done by registries. If the skin is directly managed by the account,
						the in-game management of skins would be a lot simpler, without bothering with
						the records. The "missing" textures should be done in a higher level class than
						this. If the texture atlas system is done, there is no need to manage the sheets
						of all the sprites like this even loaded entire from the assets. The
						<code>SpriteMeta</code>, probably ignored, to be smashed and remade. The
						<code>SpriteType</code> logic is quite messy, they should just be registry things.
						Sprites and <code>SpriteLink</code>, quite complex though, too much. Why would
						there need to mirror the tiles respectively without mirroring the relative
						positions of them in a sprite? It is probably just because there is no a
						well-made filtering mechanism in the rendering system. OpenGL has these
						functionalities.
					</p>
					<p> =12=
						If achievements become account-based, all the data would come from server instead
						of application assets. The implementation would probably like the Xbox achievements
						in Minecraft: Bedrock Edition. Anyway, the code, logic or parts that are not related
						to the UI should be separated from the classes, like the loading thing or achievement
						management. The achievement notification could be a lot better, like using toasts.
						The original unit class <code>Achievement</code> is quite light, with only a few
						fields, with other parts in the display class, but not organized well.
					</p>
					<p> =05=
						Toast is quite a good idea, but the implementation could still be improved. There
						are application (system) toasts and gameplay toasts, having similar properties, but
						they are used in different places. To make them separated, a better way could be
						putting application notifications in the bottom-right corner like the system
						notifications and gameplay notifications in the top-right corner. Players could still
						access the gameplay notification center in the inventory menu screens and the
						application notification center in the pause menu or any other screen outside game.
						The content should be formatted text, but somewhere, there could be bold title with
						details by an external function forming the resultant formatted text. There would not
						be too frequent for the instances, so the frames could be fully instantiated without
						using singletons. The constructor could be similar, that parameters are mostly decided
						by the subclasses with optional extra parameters. The sprite property could also be
						abstract property instead of constructor parameter with field, such patterns could be
						generalized as a code style. It accepts nullable for custom rendering, but should only
						with sprites for simplification. Animations could be supported, but it is another
						topic. <code>AchievementUnlockToast</code> is not that good usage. Still, there should
						be a better to handle the content, frame and animations.
					</p>
					<p> =13=
						For the <code>BookDisplay</code>, most probably the previous trial to implement the
						editable books, but the way to handle text fields could really be better. More details
						should be discussed later. Books without the title and page count are not books and
						should never use this class.
					</p>
					<p> =12=
						There could still be the <code>HowToPlayDisplay</code> screen. Firstly, the
						rendering of keys could be enhanced with using images, which are the mapped
						keys, but not the names of the mappings. All the paragraphs would be put into
						a single translation entry to simplify this thing, but there may be ignorable
						odd double line breaks between paragraphs. There would be actually 3 types of
						controls: Keyboard Only, Mouse &amp; Keyboard, Controller. No fallback, so when
						any controller is disconnected, keyboard would still not usable, unless it is
						"Controller &amp; Keyboard", with the pattern that "major-first-minor-second".
						For every set of controls, there would be a guide, with topics in the subtopics
						under each setting of control. If there are guides without <i>any</i> control,
						they should be placed aside the control guides. Usage guidelines for each set
						of controls could be different, but most of the basic functionalities would
						still be usable. Control guides should be put into control guides; general
						gameplay guides should be put into general guides. However, advanced guides
						would not be placed here, but instead other places, like with a wiki. The
						layout of this screen may refer to the one in Minecraft: Bedrock Edition.
					</p>
					<p> =13=
						There is no the real need of <code>PagedDisplay</code>. It could really be replaced
						by using a scroll pane, which is even more easy-to-use than pages, unless they
						are really books, but not the case. Not much to notice, this class could be dropped.
					</p>
					<p> =12=
						For <code>QuestsDisplay</code>, the management part could be separated like how
						advancements should have been done. This kind of quest tree display would be quite
						complex, so keyboard navigation would be available only on keyboard-only mode; or
						the mouse should be used to drag. Like mentioned in other mechanisms like OSK keys,
						the components could be linked. There are various ways to display the node description
						in the tree layout: the first way is using tooltips; the second way is showing the
						content in a separate menu with the hovering node, empty if nothing hovered; the third
						way is to select the node on press and show the content in a separate menu. It would
						depend on whether there would be features supported here. As for the JSON structure,
						it would not be important when it would no longer be formatted in this way as sources.
						Full refreshing functions like <code>refreshDisplayableQuests</code> should only be
						invoked only when they are loaded or something, but not every time some elements are
						updated, which should always be done in sync with any related activities. This includes
						<code>reloadEntries</code>, though the data should not be updated in real-time even if
						they are changed, instead should be the snapshot at the time accessed for simplicity
						and also consistency. The inner subclasses of <code>Display</code> are quite complex, but
						they could just be made as submenus.
					</p>
					<p> =12=
						In the structure of quests, they are organized as series. There is no singleton quests
						but series of quests. A series includes several quests, which may be unlocked in
						sequence. When showing the menu list of series, they could be listed on the
						left-hand-side and put the tree layout on the right-hand-side menu, making use of the
						screen. If there is description for the series, it would be put on the right-hand-side,
						on the top or on the bottom, outside te tree. Certainly, while there would be 2 separate
						systems of quests and advancements, quests would not depend on the system of advancements
						but the more abstract structure. In abstraction, they are called "Progression Systems".
						Locked quests would always be hidden to prevent spoiler, but advancements may be hidden
						depending on the levels. The implementation of <code>SeriesQuestViewerDisplay</code> is
						really complex, if there is a component supporting drawing graphics in shapes this could
						be a lot simpler, in addition that the nodes could still be boxes of components. Still,
						if the components could be shapes, there is even no need for the graphics component,
						simply placing them in the component pool. Making rows and columns while they are
						unnecessarily like that would be complex, but making linking like elements in a linked
						list should be enough. That means there would also not need the map of quest
						relationships when they could just be put into the quest node component instance. Auto
						scrolling would be used only for keyboard or controller controls, or mouse dragging would
						be used instead. If the quest manager is instantiated, there is no need the functions of
						<code>resetGameQuests</code> or <code>load</code>, and saving would be handled by a world
						save manager. There are no need separated tabs for unlocked and completed series, but
						probably a select dropdown for showing all, only unlocked or only completed series, and
						the display menu on the right would be empty if no series is selected in the tab.
					</p>
					<p> =01=
						There may be different sets of directions or positions, but they should be managed in a
						standardized way, with their enum classes. For example, there would be sets of 2, 4, 5,
						8 or 9 directions. <code>RelPos</code> is an example of a set of 9 directions in a
						rectangle. A border layout would use a set of 5 directions. <code>xIndex</code> and
						<code>yIndex</code> should rather be computed on demand according to the natures of
						<code>ordinal</code>. To be value-safe, functions like <code>getPos</code> would be
						avoided, and <code>getOpposite</code> would use switch-case or when instead. If there
						must be a value of anchor based on <code>Point</code> and <code>RelPos</code> specified,
						a dedicated class of <code>Anchor</code> could exist.
					</p>
					<p> =16=
						The resource packs and similar things would no longer rely on the directory
						structures. There would be several categories of the assets. The only supported
						version of the packs should only be the one the version of the application was
						designed for, and the older packs may only be loaded with minimal supports
						where possible. As for the vanilla assets, if all the assets are configurable,
						they should be packed as one and either embedded in the binary or as an external
						asset, but modifications to it is disallowed and thus only loaded once on start.
						There is no longer the need to traverse the embedded assets. The screen would
						still be 2 tabs with the left unloaded and the right to load. With a higher
						resolution, there is really no need to combine them into one list while it could
						reduce the discoverability of the list. Only the brief description of the packs
						would be needed, so the screen does not have to be detailed. The watcher would
						monitor all the packs. When leaving this screen, all the packs are loaded into
						memory, and the packs would not be locked, so all the packs except vanilla
						assets would be reloaded even if there is no change while on this screen. For
						the list entries, if there are new items added to the list, the selected one
						would be kept selected but shifted, and the selection would be removed if the
						entry is removed; the list entries would not be said to be selected by the mouse,
						but for the other controls. The file watcher, would be itself as a utility class,
						so would not be the inner class of the display class or such. On the other hand,
						they are locked to ensure it would not be modified during loading. If they are
						keyboard or controller controls, the packs could only be moved while selected.
						Then, the list entries are also likely linked. For reading the information of
						the pack, "soft read" lock would only be needed, the dimensions of the logo
						would not be limited, but there are always the optimal ones. This stream handling
						part is actually quite low level. There would also no need for the filter to
						get the assets content. Depending on the assets, mostly only the embedded assets
						may use the <code>readStringFromInputStream</code> function, but not a must. The
						metadata would no longer be a single file, and most content may not use the JSON
						structures.
					</p>
					<p> =16=
						The steps to load packs on start during initialization would be:
						<list>
							<li>Load directory for packs.</li>
							<li>Match packs with preferences.</li>
							<li>Select matched packs and ignore others, warnings may be emitted.</li>
							<li>Hard lock all the packs including vanilla assets.</li>
							<li>Validate vanilla assets with a checksum, an error may be emitted.</li>
							<li>Load all the packs in order into the memory.</li>
							<li>Release all the packs.</li>
							<li>Finish initialization.</li>
						</list>
						Note that the assets for the loading screen would be embedded, but it is possible
						that there could be a "booting" screen configured after loading.
					</p>
					<p> =16=
						The steps to load packs after saving the pack preferences would be:
						<list>
							<li>Unload all the assets except vanilla assets.</li>
							<li>Select matched packs and hard lock packs, errors may be emitted.</li>
							<li>If reversible errors are emitted, return to the pack list screen.</li>
							<li>If any pack is updated during the process, return the screen.</li>
							<li>Load all the packs in order into the memory.</li>
							<li>Release all the packs.</li>
						</list>
						Obviously, the way to manage the vanilla assets is quite different from custom
						packs, but the format and specification would still be the same. The part which
						matters would only be how the pack manager works to align with the standard system.
					</p>
					<p> =16=
						Since it would involve different stages for initialization and configuration, there
						may not only be the single manager for the packs. Post-construction initialization
						would not be design-safe, so the stages may be separated into several utility parts
						for the entire pack management system. Individual packs would be on their own, but
						the workflows must be safe enough as designed.
					</p>
					<p> =16=
						For pack loading, all the parts would just be handled by a function with the manager.
						Skins would be handled separately from the assets. If assets loading is handled in the
						lower level, the processing code may not be here. As for loading packs, the exceptions
						would only take for a single pack, but the entire loading process would be stopped for
						strict mode. Also, the compatible mode would skip some unimportant exceptions and allow
						loading old versions.
					</p>
					<p> =12=
						Tutorials should be reworked. However, they could just be in the How to Play screen
						or as guides configured in the menus, which could be referred from RimWorld. As for
						completion detection, those may be detected in realtime, including the interactive
						elements and input events. The one in Minecraft is not valuable for reference here.
					</p>
					<p> =07=
						As for the world names, there should be no limitation. Therefore, the directory names
						of worlds would be differently handled, by a randomly generated character table of
						alphanumerics by indices, with an incrementing counter. Both the table and the counter
						are stored as "internal" data of the client application. In normal operation, the
						directory names must not be modified as there would be an internal table storing the
						directory names as the identifiers for some preference-related local user data, like
						the last played world. Since there is a chance that an unexpected collision occurs,
						so a warning would be emitted and such string would be skipped. Overall, the string
						would seemingly be incremented as 62-based and likely random. On the other hand,
						server data are not stored on the client side, but sent on demand, only the server
						configurations and primary metadata are stored in client application data. Then, there
						is totally no need to check the names with any regular expression. Players are more
						advised to access the world directory via an application rather than a filesystem
						browser, and edit most files with advanced editors. This way, players must use the
						application to import or export worlds, even making backups, the launcher might also
						support such operations. Even worlds with duplicated names could exist, so it is
						advised to make the name identifiable and unique, a warning would be shown if such
						scenario occurs, but the name would still be saved as is instead of being modified
						to become unique.
					</p>
					<p> =07=
						The <code>WorldCreateDisplay</code> would be renamed and accessed from the world list
						screen listing local worlds. The screen would only handle the inputs, all the
						user-specified settings. If some of them are empty or remained as "default" without any
						customization, the default values would be filled during the initialization of world
						creation process. The seed field would accept any character but further hashed with
						a custom hasher even they are numbers, so an option to input real numeric seed would be
						provided near the input field. If there is any field containing illegal characters or
						unknown values, they would be marked as "unparsable" and the button to complete would be
						disabled. There is also no need to show what name would be saved eventually. The setting
						fields would be initialized only on this screen, so no any settings are saved after world
						creation, and they would not be saved as global states like the <code>Settings</code>.
						The <code>WorldSettings</code> class would be a record class storing all the input values,
						declared not in the screen class.
					</p>
					<p> =07=
						In the world list screen, there would be several operations available, including importing,
						exporting, copying, deleting and creating worlds, where exporting, copying and deleting
						could only be done on existing worlds. Basically, the <code>WorldInfo</code> class might
						be just the similar record class with fewer information, but with an addition of world
						size on disk. The icon of world can be customized but the default icon would be the same.
						Note that the world version shown would not be the actual logical data version but the
						display version that the version of the game last accessed. The directory name would not
						be shown however, but the user could open the world folder via the browser by a button,
						labelled "Open Folder", or as a button on the selection, so that there is no need to show
						disabled buttons. Then, the user has to press the play button on the selection, although
						there might be optional quick access by double-clicking the entry, disabled by default.
						Since the screen would be a lot finer and larger, the world information would be shown
						within the entry instead of the separate menu. If there is any data stored a world key
						which does not exist, such data would become unknown. While the screen is opened, the
						watcher thread would keep tracking of the changes notified by the filesystem and the
						operating system. While there is an operation emitted in the screen menu, the world
						data of the selected entry would be sent as argument, without using the static fields.
						Too much duplicate code in the ticking method, but many parts could be separated and
						simplified.
					</p>
					<p> =07=
						The process to load world information would differ a lot from the original one. Also,
						having methods of <code>setWorldName</code> and <code>hasLoadedWorld</code> is really
						weird. <code>getValidWorldName</code> would not be needed. To simplify the process,
						copying world could just be a simple "duplicate", appending "Copy of" in the front of
						the original world name. User has to edit the world to change the name afterward, or
						the user could enter a different name than the default given name in a similar dialog
						like the one in IntelliJ.
					</p>
					<p> =18=
						When an entity is added into the world, an identifier would be passed into the constructor
						of the entity. The identifier would be unique to the world and thus readonly. Since the
						removal of entity would be handled on each tick of world updates and there would not be
						a field saving the boolean whether it is removed, everything would still be taken into
						account without knowing whether the entity is still in the world next tick, it is advised
						to avoid pure incoming references existing more than a tick on the target entity. The
						models of entities should be hidden and immune to direct external impacts but rely on
						internal states. There might be a record class of <code>EntityPrototype</code> before
						the construction of entity, by storing all the controls. By the way, entity color is
						really pointless.
					</p>
					<p> =09=
						The rendering part of entity is mainly responsible by the texture models, but the
						appearance may be different depending on the entity states and properties. For this,
						an extra control element might be better than using method overrides. Moreover, the
						interactive models are handled differently and only affect physics, while both are
						stored in the entity. Still note that the interactive models should be simpler than
						the texture models, since textures may be preloaded as atlas.
					</p>
					<p> =19=
						It is not a good way to have both <code>isSolid</code> and <code>blocks</code> to handle
						collision conditions. A better way may still be having only <code>blocks</code> and
						assessing entity data on collision if necessary.
					</p>
					<p> =19=
						Movement would mostly be tackled by the physics engine, so there is no need to worry about
						the <code>move</code> methods for entities. However, the velocity and acceleration
						controls matter, thus they would be managed by move controls. The actual implementation
						for the algorithm used sub-stepping by breaking down the movement unit by unit, but
						unrealizable for a decimal coordinates system. Before the algorithm was implemented,
						tunneling actually occurred for increased speed, which had also been reported in fact.
					</p>
					<p> =18=
						Despawning would also be handled by a dedicated control. This way, if the entity does not
						support despawning, the control would be null instead. This also includes the call when
						the entities are removed or killed. Moreover, the methods for "delegations" of controls
						could actually be inline functions as they are just helper methods, added that controls
						could be dynamically added, so the scopes and ranges of them could not be limited. The
						same as <code>ItemHolder</code>. Control classes may also add extension functions to
						master classes like <code>Entity</code>.
					</p>
					<p> =01=
						Both <code>Tickable</code> and <code>ClientTickable</code> have no use. There is no point
						to have them, so the reason behind this cannot be found. The <code>Direction</code> is
						actually the entity activity direction, but when it would not be 4 or 5 only, the enum
						would become insufficient. For direction system other than the compass directions, a
						vector in spherical coordinates with a unit length would be used.
					</p>
					<p> =21=
						Having <code>ExplosionTileTicker</code> as the animation is actually a bad idea. In fact,
						using tiles as the animations is a bad design idea itself already. Given the tile system
						that ticking of tiles are random, but tile entities are ticked regularly, the transitional
						state as a tile could interfere the design consistency of the entire system. Apparently,
						other than having a transitional tile, particle animations with immediate tile destruction
						are a more consistent way to the system. <code>ExplodedTile</code> should be removed.
					</p>
					<p> =19=
						The mechanisms and situation of <code>Arrow</code> has been explained before. When there
						is the new entity system, this could also actually be solved way more easily, including
						the collision detection. Also, no idea why the check of tile with ID 16, which is lapis
						ore?
					</p>
					<p> =19=
						Although <code>ItemEntity</code> itself would not have acceleration, initial velocity and
						frictions on the ground could still be applied. Most likely, the code has messed up what
						"velocity" and "acceleration" actually mean in mechanics. Ideally, each Item Entity
						should only represent a stack of item(s). There could also be two separate properties for
						the total time lasted and the remaining time before deletion. If the remaining time is
						null, the entity would never be deleted. The two fields for synchronization are quite
						meaningless. When there is the 3D world system, there is no need to solely calculate
						the vertical motion of the entities for animation, as well as the shadows, which could
						also be standardized across different entities. The class would provide a factory method
						to initialize the entity, instead of by <code>Level</code>. However, the initial
						direction and velocities of the entities should not be determined within the
						constructor but with factor methods that handle differently for dropping items and loots.
					</p>
					<p> ====
						If there is something that runtime lists may not do much, static fields may actually
						more debugging-friendly.
					</p>
					<p> =18=
						As for <code>Composter</code>, there could be more details in the mechanisms. It may
						still depend on the direction of the game, but most likely, everything could be harder
						and more complex.
					</p>
					<p> ====
						The string analysing and parsing way is too error-prone. In fact, we should rather let compiler
						complain than allow runtime errors or subtle bugs to occur, and reducing the amount of
						code does not mean improving runtime performance, even using loops to reduce the parts
						of code does not mean the method is wise or the developer is smart.
					</p>
					<p> =10=
						<code>Lantern</code> could be just one of the advanced artificial light source options.
						The way to handle lighting could be really better. The current way does not handle light
						blocking by objects, but actually gameplay experience could be enhanced if it could be
						done. The way to if-else chain the enums could be changed into switch-cases if the JDK
						version could be raised, but in Kotlin, <code>when</code> could be used.
					</p>
					<p> ====
						Actually, in the structure of Kotlin, some constructor parameters could be simplified
						to abstract properties. Also, not everything has to be in the constructors but the
						factor helper methods.
					</p>
					<p> =18=
						The mechanisms of <code>Spawner</code> are quite "<i>reflective</i>". However, this thing
						would less likely be implemented into TerraModulus. Even if there is a need to have a
						machine to generate mobs, a better interface should be made to prevent low level code
						structure. Also, the way to detect daylight to skip spawning could be improved if the
						lighting system is changed.
					</p>
					<p> =19=
						<code>Tnt</code> may
						remain as <code>Furniture</code>, but more visual effects could be added. Also,
						interactions due to explosion could be standardized into general explosion algorithms
						for both entities and tiles, especially the factors of exposure and ranges, although
						the calculations of interactions of entities and tiles would still be separated. There
						would also be different attributes for an explosion. However, there might be different
						types of explosions, like gas or fire.
					</p>
					<p> =19=
						If the character moves from
						zero by walking, the velocity should increase gradually in a period like a second, to
						better simulate the motion.
					</p>
					<p> =18=
						The <code>walkDist</code> field in <code>Mob</code> only relates to the sprite animation
						but no other uses. Such data should be grouped together within an object, so that the
						objects could be responsible for the master class. The walking distance for statistics should also be handled
						by the move control. There should also be another object storing all the geologic data
						of the mob, like the position and direction. There is probably no need to have delay between
						attack damages; as for attack cooldowns, this should be implemented thoughtfully to
						balance the acts instead of receives, this kind of short period immunity may not make
						much sense. There might be a data monitoring object <code>Measure</code> to hold both the bounds
						and the actual counter of the value of measurement.
					</p>
					<p> =19=
						Knocking back by external motion would be
						handled by impact, that will be converted to a constant velocity to be resisted by
						resistance from the ground or air.
					</p>
					<p> =18=
						For spawning and despawning conditions of mobs, they may be changed depending on the
						design of the gameplay and the styles. To add a little realism, spawning of mobs may
						mostly be held during world generation without natural despawning.
						<code>noActionTime</code> in <code>Mob</code> is just for despawning check, and the
						<code>speed</code> field is also not useful.
					</p>
					<p> =09=
						For mob sprites, the compilation would be generalized into a kind of
						models.
					</p>
					<p> =18=
						Explosion damage would be sent from explosion directly to the
						entity, rather than an event interface <code>onExploded</code>.
					</p>
					<p> =23=
						The burn command to a mob could become a dynamic property of a mob, as a
						property assignment.
					</p>
					<p> =18=
						The level of mob is another mechanism, but unlikely to be generally implemented.
					</p>
					<p> =18=
						The generation of mobs should be handled in world generation.
					</p>
					<p> =18=
						There is actually no need to have a field of <code>color</code> in
						<code>PassiveMob</code>. The behaviors like grazing could be more realistic, like
						having a countdown in the action. Both hostile and neutral mobs could have a list
						of enemies for tracking. In code, it seems like spawner is immune to creeper, but the
						way is too chaotic. Many mobs have only simple mechanisms without obvious difference.
					</p>
					<p> =09=
						If the models of mob are standardized, there is no need to have
						separate sprite sets for player carrying textures. Rendering of player is quite straightforward, like swimming
						and item holding, even falling, but item holding might but clearer, not only when
						they are being used.
					</p>
					<p> =25=
						All fishing-related code should all be handled in the item class.
					</p>
					<p> =21=
						For particles, each particle entity should represent one unit of sprite for
						consistency. Also, they are not expected to have active interactions with other
						world objects. The <code>TextParticle</code> is actually not like particles, but other
						kind of visual effects, and the effects are too much for a particle. The mechanism of
						<code>WaterParticle</code> is actually too complex, but the code could have been
						simplified if initial velocities could be supported as general entity mechanisms.
					</p>
					<p> =09=
						When an item is being rendered, most of the time it would be on the Heads-Up Display
						(HUD) or in inventory menus. Other chances to be the sprites of item entities. The
						difference is that, when they are rendered on the Graphical User Interface (GUI),
						some extra information like durability may also be rendered along with the model of
						the item. Therefore, models and the GUI rendering functions would be separated for
						items.
					</p>
					<p> =23=
						The data part of item has failed, but all the metadata/properties and display
						information should have been separately provided for different usages by different
						ways, that description is one of the display information.
					</p>
					<p> =26=
						When items are linked by
						resource keys, there would not be the need to associate the sprites or models
						manually one by one.
					</p>
					<p> =23=
						Some attributes of items may be hardcoded for an item, but some may be dynamic.
						Internal attributes would become item properties while public ones would become item
						tags. Any of them could be either dynamic or static.
					</p>
					<p> =13=
						If the nature of books is to be an item in the world with content stored, it is not
						recommended to have them translated unless they are a special type of books. It is
						because there could be inconsistencies between server and client sides if the stored
						content may differ between different client settings. Thus, for the static books
						generated or originated from the game internals, like the "Antidious" book, they
						should be handled in a separate item instead of regular book item. This is to
						support client side translation, which clients would support. This means
						<code>BookData</code> would be an outdated structure. This kind of static content
						should be handled by assets instead of being in the code.
					</p>
					<p> =27=
						<code>BucketItem</code> should contain fluid instead of tile. Hole does not make sense
						but null since this kind of item is intended to contain actual fluid or liquid. The
						<code>offset</code> field is no longer useful when they are cut down to smaller
						sprites from an entire sprite sheet, could be replaced by <code>ordinal()</code>.
					</p>
					<p> =24=
						<code>ClothingItem</code> has been an issue for long time. There is actually no
						real use for the original mechanism, but it could be rewritten like Leather Armor
						in Minecraft.
					</p>
					<p> =24=
						In fact, dyes could be more flexible than having a small set of colors, but a wide
						range of colors like 32-bit RGB set. A limitation would be that dyed objects may
						be hardly modelled, so a blending or color mapping function may be necessary. A
						1-bit image could be used for tinting textures with the given tinting function.
					</p>
					<p> =25=
						<code>FishingData</code> could be turned into resources linked by resource keys.
						It might be more realistic if string could be broken when stretched too much, that
						players have to change the string. Fishing rods would be only able to catch fishing
						but not other items. Also, rods could be used anywhere.
					</p>
					<p> =23=
						If there would be a new food system with various recipes, the materials could contain
						fewer attributes as they are similar item type. Eating food would still cost stamina
						anyway.
					</p>
					<p> =23=
						If there would be potion effects supported, they would be generally supported as an
						interface for all living mobs. Also, there would be a registry for storing all the
						potion effect types and the handlers, so that it could be a public interface.
					</p>
					<p> =25=
						For <code>ToolType</code>, it would not be an enum, but a typical class, with all the
						instances stored as constants. All the <code>ToolItem</code> instances would use the
						references to the types for construction, without any looping. The tool type would be
						stored as item property. However, if all the tiles have a health system, there might
						not be a kind of mining level system for tools. Still, there could be two meters of
						health that when a suitable tool is used, a mining meter could be used. Also, if
						some tools could harvest a resource with only one action, the health meter could be
						ignored, and thus the aforementioned concern would be invalid. Durability of tool
						would not be set in the type but only in the item instances. It is possible that
						there could be a material that there is no a tool type specifically for it. For
						attack damage bonuses, there could be a mapping to collections for tools, taking
						attacker and attack targets as parameters, and eventually sent to the collection
						for the specific tool; the entire collection would then be registered to the tool.
					</p>
					<p> =21=
						The glint particle in <code>WateringCanItem</code> should be registered. Besides,
						the splashing particles could be handled better, to a more generalized extent.
						The working mechanisms of this are actually quite magical, but could be rewritten.
						Also, it should not take the tile player selected as the target but the area of
						tiles close to the player.
					</p>
					<p> =23=
						All the tiles may have a list of properties,
						such as flammability, material type, hardness, blast resistance, luminosity, etc.
					</p>
					<p> =26=
						Instead of <code>Tile$Material</code>,
						Some tools may rely on various tile properties, but not with an enum. Identifiers may only
						be stored in the registry instead of within tile instance, but a resource entry may
						be returned to include the resource key along with the resource object. Other usages
						of this enum should be replaced by tile properties or metadata. Also, having this
						as argument may have limited the variations of tiles.
					</p>
					<p> =07=
						<code>ConnectTile</code> should be removed. With a theoretically infinitely
						large world, there should be no boundaries visible or discoverable by players
						normally when players should be limited to the inner soft world boundaries
						with no normal access outside the boundaries.
					</p>
					<p> =26=
						There is no much advantage in using enum than general constructors and fields
						for <code>DecorTile</code>. Instead, when tiles are registered and stored as
						fields, the arguments would be directly passed into the constructors.
					</p>
					<p> =23=
						The metadata and models of a tile should not rely on the positions of the tile.
						The mechanisms of having variants of tiles in <code>DirtTile</code> do not obey
						this.
					</p>
					<p> =07=
						There might also be some rocks tiles with little or more content of ores or other minerals.
					</p>
					<p> =27=
						Some systems like plants may not purely rely on the tile instances but the classes
						of plants registered into the game. Then, tiles, items, etc., would be registered
						according to the registries of these plants. This includes trees, crops, flowers,
						grass, etc. Both <code>TreeTile</code>, <code>FlowerTile</code> and
						<code>CropTile</code> would be combined for mechanisms in this sense, although
						there might still be some differences in the details for different types of plants.
						This includes fertilization.
					</p>
					<p> =26=
						The approaches in <code>Tiles</code> and <code>Items</code> are quite low level and chaotic.
					</p>
					<p> =28=
						<code>canWool</code> is actually a mechanism that does not really make sense. For the
						logic, this should be a feature that may be removed in the game. Also, having a
						carpet tile may be better than a wool tile.
					</p>
					<p> =26=
						If <code>FarmTile</code> is a variant of <code>DirtTile</code>, both could actually be
						combined in the mechanisms. When the dirt tile has reached a certain level of moisture
						and nutrition, crops could be growing on it. Thus, there is no need to add another
						tile, especially for a variant or a state of a tile. Crops may also grow and interact
						according to the status of the dirt tile underneath.
					</p>
					<p> =27=
						For the variations of crops and plants, there could be real-life species as well as
						fantasy species, like the heavenly berries and hellish berries. Mechanisms like
						harvesting, growing stages, diseases, nutrition, etc., would all be implemented for
						all kinds of plants.
					</p>
					<p> =07=
						Only the chunk generator in the dimension would take the dimension seed as argument.
						Other events that take randomness would instead use thread random number generators.
						During the initialization of dimension, the generators would be initialized, but
						generation would not take place before generation commands were sent. It is not
						recommended to generate structures at a certain location on a world without any
						major pattern.
					</p>
					<p> =10=
						Background of the world would be handled by shaders, so the scene may not be static.
						Entity rendering would be controlled by rendering distance configured by the client.
						Light rendering would be controlled by shaders based on the tile light values,
						light blending and raytracing would also be programmed by shaders, without the
						information of entity lighting, including the sight blocking from player.
					</p>
					<p> =01=
						Coordinates, such as x and y, would not be treated as separate parameters. Instead,
						they would be consolidated into a single entity, particularly when representing a
						vector or an object's position. This approach ensures that positional data is conveyed
						as a unified parameter, whether in the form of a simple vector, a tile position
						referencing a dimension, or another integrated structure. When returning entries,
						like a tile from chunk manager, an entry describing the positions and the specified
						tile type with all the metadata included would be created, so the data could also be
						modified directly without invoking extra methods. Entity instantiations and removals
						may also be handled in the similar way.
					</p>
					<p> =18=
						If mobs are spawned only during world generation, additional natural spawning may
						not be implemented. Therefore, chunk manager would not handle any mob natural
						spawning interface. While all ordinary structures would only be spawned during
						world generation in the dedicated areas, no spawner-like device would be
						implemented. Village generation should actually be standardized like a general
						structure.
					</p>
					<p> =07=
						World generation would be handled by a manager with registries of generation
						parameters, functions and configurations. This would be aided by a random number
						generator with the seeds provided in the code for the generation process. The
						generator would always be available for chunk generations as the world is still
						loaded. All the generation configurations would not be hardcoded in the code but
						separately for the public customization interface. However, the primary functions
						would be supported by the interface for generator configuration, including sampling
						functions and random number generator algorithms.
					</p>
					<p> =07=
						If world size is theoretically unlimited, there is no need to validate anything
						when the generator is designed well. Also, it is challenging to design a suitable
						testing function to validate the content of the world, especially when they are
						generated parts by parts.
					</p>
					<p> =07=
						If world generation tends to be fancy, consisting of a lot of variations, it would
						not be simple as only with switch-cases, loops and if-else conditions. Also, even
						if the entire generation is desired to be fully programmed, constants should be
						more manageable, like being defined in the fields or the top level. The caves
						would not be horizontal.
					</p>
					<p> =07=
						The dungeon is an example of unordinary dimension generation, which is not set by
						general algorithms but major design patterns. The boss room and dungeon gate
						structure generations are the obvious evidence, they are generated toward the
						center. To support such generation patterns, there may be the need of scripts
						instead of simply just lists of attributes and properties. This means the system
						would not use data structures like JavaScript Object Notation (JSON).
					</p>
					<p> =07=
						The map generation testing function should not be included in the production code.
						The main reason is that it could become a redundant part of the release whilst not
						accessible without altering hidden launching parameters. There might another module
						to manually enter parameters to visually examining the results and the effectiveness
						of the configurations and algorithms.
					</p>
					<p> =07=
						Early world generations such as terrains would be done in the Rust part. After
						generation, chunk data would be sent back to the Kotlin part for further populations.
						Features are small scale decorative elements, being as tile placements, while
						structures are large scale templates and logics of tiles and entities with data and
						parameters. Jigsaws are presets of the templates to be used by structures. Most of
						them would come with custom data formats while generator configurations, features
						and structure definitions may come with scripting. This should be able to ensure
						that the supports are extensive, flexible, customizable, modularized and
						standardized enough.
					</p>
					<p> =12=
						Advancements and quests share similar properties and natures, so a common superclass
						should be made for simplification. A more important part is that most vanilla
						modularized components should be able to be easily disabled in the same public
						interface. There should be categories for advancements to organize for different
						topics of progress; would still be series for quests. Even if they have
						categorization, groupings may also be used within a category or a series, or in other
						words, a category or a series may contain more than one tree of elements. To let the
						progress be recorded, the elements or units could require both preceding elements
						and completion criteria to be both exist, that the criteria may be recorded preventing
						requiring repeated completion after the preceding elements being completed when they
						have already been fulfilled. All the elements would still be tree-linked with the
						preceding elements to be the requirement for the succeeding elements to be able to
						be completed. The configuration may no longer use JSON to define the structure for
						the ease of creation and parsing. When the preceding elements have already to be
						completed, the succeeding elements should be unlocked unless they are necessarily
						hidden; if completing an element requiring completing another element, it should be
						included as a kind of criteria instead of being a "requirement" as both "criterion"
						and "requirement" have similar meanings. Also, rewards should be abstract and with
						a list for each element. Each criterion may follow with description and the boolean
						value of whether to be visible. <code>AdvancementTrigger</code> should be renamed
						to <code>AdvancementTracker</code> for clarity. Trackers would also be in a registry,
						to let the conditions of criteria to be detected and fulfilled. In fact, trackers
						and condition handlers may also be constructed as anonymous classes. For working
						instances, they may have the references to the metadata of the elements and also
						the status of the elements for each tracking target, either global or player.
						Trackers should be using generic types to reduce the verbosity in using type
						checking. <code>Rangeable</code> should be separated into Minimum, Maximum and
						Range; <code>ItemConditions</code> could be simplified to a counting-based instead
						stack-based basis; there should be no no-op criterion and tracker but empty for the
						element to simplify the structure. During the processing of elements, the game
						should not be saved for progress synchronization. When passing a record to trackers
						to track for, a criterion working instance and the element working instance could
						be bundled in a new record object instead of being mutually included to simplify
						the structure.
					</p>
					<p> =12=
						Although most main utility parts of the advancement system are in the
						<code>AdvancementElement</code> class, since the amount of code is quite high, it
						would still be better to separate the content for different responsibilities in a
						separate package. If recipes can be disabled, they should be in a separate public
						interface, so not only advancements could be able to handle recipe locking. An
						advancement category may be per-user basis or global, depending on the nature of
						the topic.
					</p>
					<p> =12=
						A different of quests from advancements is that quests may have prerequisites to
						be unlocked before to be able to be completed, so the completing criteria may not
						even be tracked before being unlocked. However, the quest system would follow the
						similar structure as the advancement system since the original style has been
						outdated.
					</p>
					<p> =01=
						Most functions in <code>MyUtils</code> could be replaced by the helper functions
						from various utility libraries. If there are functions designed specifically for
						this codebase, they may actually be declared as top level functions for simplicity.
					</p>
					<p> =01=
						Unfortunately, due to the coordinate system implementation, the <code>Vector2</code>
						class is not fully utilized in code. There would be several classes to represent
						different forms of vectors with different parameters and properties. However, it
						is important to note that they should all be record classes with all the fields
						immutable, to be treated as primitive-like values.
					</p>
				</content>
			</section>
			<section title="Extra Notes">
				<content>
					<p>
						While doing the low level programming anywhere, even in the Kotlin parts, careful
						coding is always required. It means, extra attentions are always needed, to ensure
						the logics make sense without heavily relying on the compiler while the compiler
						may not give valuable information just by the errors or warnings. This is especially
						important while porting low level APIs to the higher level places, since it may
						sometimes be forgotten.
					</p>
					<p>
						When there are some utility classes, the internal code may be somehow lower level,
						so the above rules apply. Also, the resultant syntax of the usages should be
						idiomatic in Kotlin or even practical according to the code patterns.
					</p>
					<p>
						Listeners must be handled well. They are registered when they are set up, but they
						should be unregistered when the holders of the event listeners are destroyed, or
						they are no longer used. There should be no "zombie" listeners happening. This
						could only be ensured by the developers, and the compiler could not validate this.
						Try-finally may be used if it is inside a try-catch block.
					</p>
					<p>
						In fact, when the constructions of classes are limited, as long as they are still
						in the scope of context, they should be safe to be public. This covers the cases
						when particularly some classes are doing their responsibilities in their domains
						for other parts. This case, if the source data are from the other parts where the
						creations are already limited and the classes in the domain are using the source
						data with the publicly exposed classes definitions, the source data are still
						limited in the scope safely even they are in the other domains as long as they
						are well-designed.
					</p>
					<p>
						Visibilities of code entities should be handled well and logical enough. If there
						exist some functions or constants that are general, they could be considered
						being moved out of the class. Also, if some members are designed to be used in
						a specific scope, they should not be highly visible to prevent breaking mechanisms.
					</p>
					<p>
						If a numerical countdown involves a specific event as designed, it should not be
						made as a countup unless there are more events associated to this counter. However,
						specifically, if the event dominates, there may still be a countdown designed for
						the event and the countup for the others. If it involves time, increment or decrement
						should be done at the end of the ticking function, and all the conditions regarding
						the counter should be done prior than counter updates.
					</p>
					<p>
						When there is no necessity, avoid singletons. This is to avoid unnecessary verbosity
						caused by the extra unused code regenerated by declaring classes as singletons.
					</p>
					<p>
						For a single file, there should be no more than two levels of inner classes in
						general. This is to prevent unnecessary verbosity and ensure simplicity,
						organization and readability of class structures.
					</p>
					<p>
						Extension functions should be used wisely to prevent unnecessary pollutions. This may
						greatly affect coding experience.
					</p>
					<p>
						Classes that are solely referenced by another class within a package containing multiple
						related components should ideally be nested within the class utilizing them,
						particularly when thematic organization applies.
					</p>
					<p>
						There should be a guideline that when initializations of fields are enough to be inlined,
						they should be kept there and not put into initialization block.
					</p>
				</content>
			</section>
		</section>
		<section title="Feature Implementation">
			<content>
				<p>
					When it is possible to not use string keys, they should be avoided. Instead, defined constants
					or enums would be used. It is because any errors caused with the strings could only
					sometimes be known in runtime, thus there could be potential bugs. It could also
					cause extra performance overheads in runtime by string representation and parsing.
				</p>
				<p> =29=
					The audio system would be remade with using OpenAL. Several features would be
					implemented. And note that no mixing algorithm would be used, only simple additions.
					This should ensure the quality of audio with consistency. When not in game, there would
					only be UI sounds and BGM; when in game, other sounds only come from the world. There
					should be no limitation with in-game sound sources, but seemingly only 2 major sources
					for non-game elements. Further implementation would be handed in the future asset
					system.
				</p>
				<p> =03=
					Many menu components are certainly required to be updated. This includes the hot bar
					and several menu frames. However, this part relates to graphics which would be discussed
					at the later stage. Rendering system may be mostly implemented ourselves for the best
					compatibility and usages, but it is still worth finding an existing meshing, modelling or
					sprite library for backing.
				</p>
				<p> =01=
					Some utility classes could be made for synchronization. For some places, synchronized
					maps and collections are needed, but the syntax should be more straightforward, like
					the <code>Mutex</code> or <code>ReadWriteLock</code> in Rust. A similarly favored class
					could be made for generic instances holding internally by the constructor with the new
					instances. This could only be ensured by the developer writing the code, though.
				</p>
				<p> =03=
					The way to handle the toggle of hardware acceleration is still a question. In
					general, there is no need to turn off hardware acceleration, but in rare cases
					the graphics cards may not be compatible with the software, so they may have to
					be turned off. However, if it has already malfunctioned when the application has
					launched, the toggle in application is quite unusable. They should either be
					configured by launching arguments or handled internally by the application.
				</p>
			</content>
		</section>
		<section title="Development Roadmap and Direction">
			<content>
				<p>

				</p>
			</content>
		</section>
	</body>
</efp>
