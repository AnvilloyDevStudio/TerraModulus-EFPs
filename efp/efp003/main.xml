<?xml version="1.1" encoding="UTF-8" ?>
<efp xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../../efp.xsd"
     efp="3" created="2025-01-30" category="informational" status="draft" title="Relictus Review Report">
	<metadata>
		<pullRequests>
			<pullRequest id="4"/>
		</pullRequests>
	</metadata>
	<body>
		<section title="Introduction">
			<content>
				In EFP 2, a plan to review TerraModulus Relictus branch has been made. This EFP describes
				about the report of the entire review process. In the following, the report will be presented
				section by section according to the previously made plan.
			</content>
		</section>
		<section title="Codebase Commentary">
			<content>
				<p>
					The source code was originally reviewed with an order but later reorganized by their
					respective topics and themes. The review has been conducted as of commit
					<code>2ba2b09bf94110efbdc36cd95ce8d74a20835205</code>.
					In the following, various content will be discussed following their headers.
					Please note that the organization of content in this section has been aided by Artificial
					Intelligence (AI).
				</p>
			</content>
			<section title="Application Initialization and Entrypoint">
				<content>
					<p>
						The application framework would include a dedicated <code>Main.kt</code> file,
						designed separately for both client and server implementations. This file contains
						the entry point <code>main</code> function, which is responsible for initializing
						the application, processing command-line arguments, and launching the primary
						handlers essential for execution.
					</p>
				</content>
			</section>
			<section title="Core Structure and System Architecture">
				<content>
					<p>
						Within the <code>core</code> package, several critical components define the
						foundation of the application's architecture.
					</p>
					<p>
						The <code>Game</code> component should be instantiated rather than implemented
						solely through static members or as a singleton. Its designated class name
						would be <code>TerraModulus</code>, with the <code>NAME</code> field defined as
						a top-level constant. Meanwhile, the <code>VERSION</code> field would be managed
						through the application profile, ensuring loading during early runtime and later
						accessibility via a getter method.
					</p>
					<p>
						<code>Initializer</code> class would be incorporated within <code>Main.kt</code>
						file, facilitating the initialization of all core threads required for application
						functionality, such as rendering and ticking threads.
					</p>
					<p>
						The <code>io</code> package would no longer reside within <code>core</code>,
						as its scope is overly generic. At a minimum, several parts would be grouped
						into <code>audio</code> package and the <code>Localization</code> class would be
						separated from it to ensure modular organization. Furthermore, all display elements
						would be registered directly to the menu, allowing a simple reload operation to
						refresh all elements without reliance on external hooks.
					</p>
					<p>
						Ticking operations would be centrally managed within the <code>TerraModulus</code>
						class. Specifically, menu ticking should be executed there, necessitating that
						<code>MenuManager</code> be placed outside <code>RenderSystem</code>, although
						rendering would still take it as a parameter. World ticking would be handled by
						its respective manager, while audio processing would operate in a separate thread
						under the control of the audio system.
					</p>
					<p>
						To enhance clarity, <code>Display</code> would be renamed to <code>Screen</code>.
						Instead of retaining the original <code>Screen</code> class, a <code>Canvas</code>
						may be introduced to manage display elements more effectively. Screen transitions
						would continue to follow a Last-In-First-Out (LIFO) linked list structure;
						however, improvements could be made to the handling of screen initialization
						and exit procedures. Rather than relying on an initializing function, a
						constructor reference could be utilized, particularly since the parent instance
						parameter is primarily intended for rendering. Passing a constructor function
						and managing parent screens within <code>MenuManager</code> would offer a more
						streamlined approach.
					</p>
				</content>
			</section>
			<section title="Window Management and Handling">
				<content>
					<p>
						Similarly, the <code>Initializer</code> class should avoid the use of static
						members. Window management would be handled through a dedicated window handler,
						which could also oversee error popups when necessary. FPS (Frames Per Second) and
						TPS (Ticks Per Second) counters would be regulated within their respective handler
						classes, ensuring proper thread management.
					</p>
					<p>
						Additionally, the application window would be launched at an early stage,
						following the initialization of essential basic elements. This approach eliminates
						the necessity of a splash screen without a visible window. The window would always
						be centered upon launch to ensure a consistent user experience.
					</p>
					<p>
						Argument parsing would be handled within the <code>Main.kt</code> file, reinforcing
						a structured approach to processing runtime configurations. The <code>run</code>
						function would reside within the <code>TerraModulus</code> class. Moreover, the
						<code>getExceptionTrace</code> function could potentially be repurposed for
						detailed error reporting, contributing to improved debugging and system reliability.
					</p>
				</content>
			</section>
			<section title="Launching Arguments and Options">
				<content>
					<p>
						The launching arguments would be systematically structured, with all options named
						using kebab case, each prefixed with double hyphens. Hardware acceleration would be
						enabled by default; however, a specific launch option to disable it would also be
						available. The fullscreen parameter would function as a toggle, determining whether
						the application starts in fullscreen mode. Regardless of the fullscreen setting, the
						window size configuration would always be applied. If no specific window dimensions
						were provided, default values would be used to ensure a consistent display.
					</p>
				</content>
			</section>
			<section title="Internal Assets">
				<content>
					<p>
						Certain assets that are not intended for modularization or customization may be
						designated as internal components. Unless explicitly required, these resources,
						including logos, would remain at the root level rather than being organized into
						separate directories.
					</p>
				</content>
			</section>
			<section title="Input Handling and Management Architecture">
				<content>
					<p>
						The <code>ClipboardHandler</code> should be managed within the broader
						<code>InputHandler</code>, as all input interactions, including keyboard and
						mouse operations, would be handled via GLFW (Graphics Library Framework).
						Consequently, there would be no necessity to implement separate interfaces for
						key input processing. The menu structure would also undergo modifications to
						ensure that key inputs are detected only by the relevant menu elements, following
						a prioritized approach.
					</p>
					<p>
						The <code>InputHandler</code> oversees numerous functionalities, including input
						processing, key mapping, controller states, and key state handling. However,
						controller management should be separated into a dedicated
						<code>ControllerManager</code>. The capability of the originally used gamepad library
						is relatively limited, necessitating enhancements in controller support. The abstract
						<code>Key</code> class and its subclasses provide essential functionality, and
						repeated key states would no longer be required. Consequently,
						<code>PhysicalKey</code> could be simplified, and <code>ControllerKey</code> would
						be deemed unnecessary. Additionally, logical operations such as "or" and "and" could
						be incorporated within the <code>Key</code> class. String-based expressions would
						be deprecated, and the <code>PhysicalKey#stayDown</code> function would likely be
						disregarded. Moreover, if key state processing results in a single <code>Key</code>
						state, subclasses such as <code>CompoundedKey</code> and <code>ORKey</code> would
						no longer be required. Key mapping would employ a distinct class rather than relying
						on the <code>Key</code> class.
					</p>
					<p>
						To improve organization and efficiency, input handling should be structured into
						four distinct classes: <code>KeyInputHandler</code>, <code>TextInputHandler</code>,
						<code>GamepadInputHandler</code>, and <code>MouseInputHandler</code>. Among these,
						<code>TextInputHandler</code> would also manage clipboard operations. Text input
						queues would be processed only upon request and reset at the start of each tick
						cycle. A regex filter could be implemented for validation, and backspace key
						operations would follow the same structured processing method. The
						<code>releaseAll</code> method would be omitted, while key hints, despite being
						complex, would likely follow a similar implementation method. Modifier keys would
						not be handled separately within the handler class. Controller vibration feedback
						would be managed by <code>ControllerManager</code> or another dedicated class, but
						controller detection and management would remain within
						<code>ControllerManager</code>.
					</p>
				</content>
			</section>
			<section title="Key Input Event Processing">
				<content>
					<p>
						Key input events triggered by GLFW would be received and queued within the main
						ticking thread. Text inputs would be restricted exclusively to text input fields,
						while keyboard inputs would remain universally active. Each keystroke transitions
						through three states: "just pressed," "down," and "just released," represented as
						boolean values. A press event sets "just pressed" and "down" to <code>true</code>,
						while a release event sets "down" to false and "just released" to <code>true</code>.
						At the start of each input tick, both "just pressed" and "just released" states
						would be reset to <code>false</code>. Subsequently, queued input events would be
						processed, updating key states accordingly, followed by window ticking operations
						that handle input. The ticking frequency should be set to 1.5 times the maximum FPS.
						If necessary, an additional ticking thread operating at a constant frequency could
						be introduced.
					</p>
					<p>
						For events such as controller port interactions, listener callbacks should be
						used instead of polling events each tick. These events occur infrequently and would
						be best handled asynchronously to prevent unnecessary processing overhead.
						Furthermore, GLFW-generated controller events inherently include the target
						controller information, eliminating the need for additional search operations.
						<code>GamepadInputHandler</code> would likely be activated only when controllers
						are enabled.
					</p>
				</content>
			</section>
			<section title="Input Mapping and Key Assignments">
				<content>
					<p>
						Input mapping should be managed separately from the input handler, allowing
						configurations based on user preferences while keeping certain mappings hardcoded.
						This includes the F3 debug key and advanced modifier functionalities involving
						<kbd>Shift</kbd>, <kbd>Ctrl</kbd>, and <kbd>Alt</kbd> modifiers. In-game inputs
						and controllers would follow similar processing principles and be handled within
						the same class structure. Mapped hotkeys should remain inactive when input fields
						are engaged, allowing standard printed key inputs while ensuring hardcoded keys
						such as escape and enter receive the appropriate handling, especially in one-line
						field or with an Input Method Editor (IME).
					</p>
					<p>
						Key mapping would employ predefined sets with the keys of constants rather than
						arbitrary string-based assignments, ensuring clarity in configuration and
						eliminating the need for loops. Mapping would strictly serve logical purposes,
						while a separate display mapping would exist for User Interface (UI) representation.
						Since the mapping configurations would only be used internally in the program, the
						necessity to use string representation would be ineffective. The mapping would be
						hardcoded, so a loop would not be used. The final input states resulting from triggered
						events would be logically combined using "or" operations to ensure all inputs are
						properly accounted for. However, no sticky key would be realized for this system.
					</p>
				</content>
			</section>
			<section title="Keyboard-Based Movement for Tile Selection">
				<content>
					<p>
						To optimize keyboard interactions for movement and tile selection, two potential
						input schemes may be considered. One approach involves using movement keys
						exclusively, with the selected tile automatically aligning with the tile positioned
						in front of the player. Alternatively, a dual-set input method could be implemented,
						where one set of keys (e.g., WASD) controls movement, while another set (e.g., arrow
						keys) allows independent tile selection by directional input.
					</p>
				</content>
			</section>
			<section title="Controller Management and On-Screen Keyboard Integration">
				<content>
					<p>
						Controller management should be enhanced through GLFW, allowing users to select
						their preferred controller. This configuration option would be adjustable via
						settings but would not be stored persistently on disk. Additionally, the On-Screen
						Keyboard (OSK) for controllers would remain available, with notable improvements to
						its underlying functionality.
					</p>
					<p>
						The <code>OnScreenKeyboardMenu</code> would likely retain its existing name but would
						include a constructor parameter accepting an input field object. A menu handle for
						the screen might also be passed, although the exact implementation remains uncertain.
						Alternatively, the OSK could function as an "invisible" menu or component, meaning it
						would be excluded from ticking and rendering processes unless actively required.
					</p>
					<p>
						Given the potential variation in key sizes, keys should be mapped through reference
						linking as components rather than predefined layouts. If a key reference is
						<code>null</code>, it would indicate that no accessible keys exist in that direction.
						Navigation would still be managed via the D-Pad, ensuring seamless controller-based
						interaction. The sticky key's state should be stored within the key object itself,
						which would also be linked to its final property. A grid layout may be employed to
						organize key positioning efficiently.
					</p>
					<p>
						All key states including whether a key is pressed or selected, should be maintained
						within the key object. The OSK would operate independently of traditional keyboard
						input and should automatically hide itself whenever no controller is detected during
						a tick cycle. Key event triggers from the OSK should be directed to the associated
						input field for processing.
					</p>
					<p>
						To ensure flexibility, an abstract class should be introduced, eliminating the need
						for <code>\0</code> as a placeholder for sticky keys. This structure would also allow
						for specialized keys that perform actions beyond text entry, such as the switch key
						to the layout of numeric and symbolic keys. Positioning would not rely on x and y
						coordinates since they are unnecessary for this implementation. Exception should not
						be abused, but managed directly within the input field instance and corresponding
						menu components. Visibility checks within the ticking function would be unnecessary,
						and rendering could be simplified by incorporating sprites into components.
					</p>
				</content>
			</section>
			<section title="Key Mapping Configuration and Restriction">
				<content>
					<p>
						During key mapping configuration, upon the first key release event, all keys
						pressed concurrently would be recorded as a key combination. However, specific
						keys, including escape, menu, and Windows keys, would be restricted from inclusion
						due to contextual compatibility requirements. The escape key would also function
						as a cancellation trigger during key detection. Notably, the escape key would
						remain hardcoded for menu control operations.
					</p>
				</content>
			</section>
			<section title="Hotkey Configurations and Key Sets">
				<content>
					<p>
						Dropping an entire item stack would be executed using the sneaking modifier
						alongside the drop hotkey. If the configured drop key sequence includes the
						sneak key, it would be considered a conflict. Each mapping should define a set
						of permitted keys within a predefined constant.
					</p>
					<p>
						<b>Permitted key sets</b>:
						<list>
							<li>
								<b>Typing Keys</b>: Letters, numbers, and punctuation characters on the
								main keypad, excluding modifiers
							</li>
							<li>
								<b>Control Keys</b>: <kbd>Ctrl</kbd>, <kbd>Alt</kbd>, <kbd>Shift</kbd>,
								<kbd>Tab</kbd>, <kbd>Enter</kbd>, <kbd>Esc</kbd>, <kbd>Enter</kbd>,
								<kbd>Backspace</kbd>, <kbd>Pause/Break</kbd>, <kbd>Insert</kbd>,
								<kbd>Delete</kbd>
							</li>
							<li><b>Function Keys</b>: <kbd>F1</kbd> to <kbd>F12</kbd></li>
							<li>
								<b>Navigation Keys</b>: <kbd>Home</kbd>, <kbd>End</kbd>,
								<kbd>Page Up</kbd>, <kbd>Page Down</kbd>
							</li>
							<li>
								<b>Numpad Keys</b>: All numpad keys except <kbd>Num Lock</kbd>
							</li>
							<li>
								<b>Forbidden Keys</b>: System-wide reserved keys, including
								lock keys, <kbd>Win</kbd>, <kbd>Context</kbd>, <kbd>Print Screen</kbd>
							</li>
						</list>
					</p>
					<p>
						Although <kbd>Tab</kbd> could be categorized as a navigation key, it has been
						excluded from that set to avoid redundancy. Unlisted keys may be disregarded.
						While checking conflicts, hardcoded keys would be taken into account to ensure
						compatibility.
					</p>
				</content>
			</section>
			<section title="Debugging Mechanisms and Interface Adjustments">
				<content>
					<p>
						Debugging functionality would be refined to ensure consistency and ease of access.
						Hotkeys related to <kbd>F3</kbd>, primarily used for toggling the debug screen,
						would remain hardcoded rather than being configurable. To maintain code consistency,
						an invisible menu session would be introduced to process both standalone <kbd>F3</kbd>
						inputs and key combinations involving <kbd>F3</kbd>. The session would activate upon
						pressing <kbd>F3</kbd> and deactivate upon sending a command or releasing the key.
						It would exclusively handle key inputs, triggering commands when applicable. For
						most keys, a direct command would be dispatched to a target, such as toggling
						debugging functions. Otherwise, upon release, the system would verify whether an
						advanced input session had been engaged. If no such session was detected, the
						debug screen toggle would be executed.
					</p>
					<p>
						Additionally, the <code>DebugPanelDisplay</code>, functioning as a Graphical User
						Interface (GUI) for commands may be deprecated if command support is fully integrated.
						Maintaining this panel would introduce unnecessary complexity, and using in-game chat
						for commands could provide a more efficient approach. Many entries currently depend
						on this menu, and transitioning to command-based interactions would simplify the
						interface.
					</p>
					<p>
						Likewise, the <code>ListItemSelectDisplay</code> could be restructured as a menu
						dialog. However, since it is exclusively utilized by the debug panel, its
						implementation would be unnecessary. Consequently, associated entries within
						<code>screen.entry.commands</code> would also be removed.
					</p>
				</content>
			</section>
			<section title="Logging System and Configuration">
				<content>
					<p>
						All application events would be logged irrespective of severity levels,
						eliminating the need for separate logging, debugging, or tracing launch options.
						Debugging functionality would be universally available, with selective toggling
						permitted in specific areas. Given the ease of creating user-generated content,
						debugging should be equally accessible. By structuring each class with a single
						responsibility, logging targets would be clearly identifiable via fully
						qualified class names, eliminating the necessity for arbitrary behavior-specific
						"title names". Log4j 2, SLF4J, and kotlin-logging would serve as the primary
						logging utilities.
					</p>
					<p>
						The logging system would transition to a different library for improved idiomatic
						usage. This change would introduce extensive logging configuration capabilities
						supported by both the library and its public interface. In adherence to Kotlin’s
						idiomatic principles, loggers would not be manually instantiated in external
						classes but would be defined based on descriptive class names. This approach
						ensures syntactic consistency and eliminates the need for custom target names.
						Since the console would typically be hidden from users, log output would remain
						as comprehensive as file-appended logs, without filtering. Additionally, logging
						configurations would be exclusively managed via programmed code, negating the
						need for customizable configurations. Notably, the Rust components of the
						application would not incorporate any logging mechanisms.
					</p>
				</content>
			</section>
			<section title="Localization and Language Settings">
				<content>
					<p>
						The debug locale would no longer be necessary, as untranslated strings would
						already be logged, ensuring careful programming without requiring translation
						key displays on-screen. Localization files would be stored within assets, with
						detailed implementation depending on the new asset system. Instead of a dedicated
						debug locale, a hotkey-based feature could highlight untranslated UI components
						dynamically. Since all entries would already be loaded into memory, switching
						languages would not require additional loading processes.
					</p>
					<p>
						Language settings should be structured as an inner class within the main settings
						system, aligning with preferences. With the debug locale removed, sorting would
						be further simplified. GUI improvements would eliminate the need for entry
						highlighting; instead, selected options could be bordered, bolded, or tinted in a
						distinguishable color. Upon exiting the menu, the chosen entry would be applied
						immediately, negating the need for a "save" button. The translation disclaimer
						could remain, while an option to force Unicode font would not be needed.
					</p>
				</content>
			</section>
			<section title="Settings Organization and UI Integration">
				<content>
					<p>
						The <code>Settings</code> system would transition to <code>Preferences</code>,
						ensuring that setting values remain independent of UI components. UI elements
						should be designed to reference and link to these settings rather than being
						treated as direct entries. World generation configurations would exist solely
						within the world generation options rather than being global entries.
						Additionally, all settings would be structured as type-specified property entries
					</p>
					<p>
						The settings screen should be unified as <code>SettingsScreen</code> rather than
						maintaining separate <code>OptionsMainMenuDisplay</code> and
						<code>OptionsWorldDisplay</code>. There should be no functional distinction
						between the settings accessible from the main menu and those available during
						gameplay. Each option would store both its original and current values, allowing
						for comparison during saving and providing a notification if changes have been
						made. Further settings menus would be instantiated only upon access, reducing
						unnecessary memory usage. The layout structure would primarily follow two models:
						<i>Submenus</i> or <i>Tabs</i> navigation, depending on stylistic choices.
						Changes would only be applied upon exiting the settings menu. Additionally,
						submenu-related buttons would end with an ellipsis when following a submenu-based
						layout.
					</p>
					<p>
						Applying changes only when menus are closed would be a more effective approach
						for managing settings. As multiple submenus may exist within the settings
						interface, UI elements linked to settings values should update exclusively upon
						menu closure. This approach would prevent frequent and potentially disruptive
						effects when users modify settings multiple times within a session.
					</p>
					<p>
						To establish clear distinctions, the following definitions apply:
						<list>
							<li>
								<b>Settings</b>: The overarching system within an application that governs
								configurations and operational adjustments, controlling various features and
								functionalities
							</li>
							<li>
								<b>Options</b>: Specific choices within a context, often presented as a list
								or menu, allowing users to customize their experience or performing specific
								actions
							</li>
							<li>
								<b>Preferences</b>: User-defined selections that determine application
								behavior, stored persistently
							</li>
							<li>
								<b>Configurations</b>: The structural setup of an application’s parameters
								and options determining behaviors and structures of application or system,
								specifying how components interact.
							</li>
						</list>
						Within this context, "Settings" encapsulates the entire configurable system,
						encompassing various "Options", while "Preferences" store individual user
						selections on disk. "Configurations" would not be used in this context.
					</p>
				</content>
			</section>
			<section title="Basic Code Structures">
				<content>
					<p> =01=
						<code>Action</code> in Kotlin could be instead a typealias of function type
						<code>() -> Unit</code>, and declared in utils. It is the similar as
						<code>Condition</code>, which could instead be <code>() -> Boolean</code>
						or a functional interface with advanced features. However,
						<code>MonoCondition</code> could be replaced by <code>Predicate</code>.
					</p>
					<p> =02=
						<code>SaveManager</code> or a similar class would handle what the upper part of
						what <code>FileHandler</code> used to handle. For other file helper functions for
						folder deletion and copying, they are already handled in Kotlin by
						<code>Path.deleteRecursively</code> and <code>File.copyRecursively</code>
						respectively. There is no need to list assets with the filesystem when we would
						have an advanced asset system implemented in the future.
					</p>
					<p> =03=
						No class would extend the major game class <code>TerraModulus</code>. The
						<code>RenderSystem</code> would only handle the top operations. UI components would
						be handled in another manager, like <code>UIManager</code> or <code>MenuManager</code>.
						The sprite management would be merged into the registry system. Everything would be
						enhanceable by hardware accelerations, so the rendering system would highly depend on
						the native libraries and the APIs, especially physics. Detailed implementation of
						graphics and physics would be discussed later. The major render system would manage
						the states of the world renderer, so the systems of UI and world graphics are
						separated. This way, several fields would be separated. Also, the window size
						would not be fixed, and there would not be something called the canvas "scale",
						but there would be UI "scale", which is a simple multiple of the base dimensions,
						available for setting depending on the window size (not saved). The entire render
						system would be backed by the rendering engine.
					</p>
					<p> =03=
						The canvas would be fully filled. The several UI elements like the app status bar
						and HUD elements (e.g. hot bar, boss bar, debug screen) would become menu components.
						Level rendering would be a part of world rendering, which includes world background
						and sky rendering.
					</p>
					<p> =05=
						Toasts are usable, but not the notification text directly on
						screen. All notifications would be replaced by chat (in game for world events) or
						toasts (any client event in game). The toasts would have their own lifetime.
					</p>
					<p> =04=
						In-game TPS would be 20 instead if 60. The length of a day would become 20 minutes
						instead of 18 so that it could be a reasonably long time and a multiple of 60, as
						the number of minutes in an hour. The game speed should be constant for several
						performance considerations, so it should not be paused. Several fields would be
						available for several values:
						<list>
							<li>
								<code>dayTime</code>: total time (number of ticks) elapsed for the game day
							</li>
							<li><code>dayCount</code>: number of days elapsed in world during gameplay</li>
							<li>
								<code>gameTime</code>: total time (number of ticks) played (elapsed) in
								world during gameplay
							</li>
						</list>
						There might be a backup routine however,
						to replace auto saving, which requires full pause of the gameplay ticking for
						game data synchronization across each part, but not allowed to pause the game
						due to the above restriction.
					</p>
					<p> =03=
						Fullscreen and screenshots would be handled instead by the render system.
					</p>
					<p> =05=
						The usages of toasts are not in the same level. <code>AppToast</code> is a subclass
						of <code>Toast</code>, but it is used in the same level as the superclass by the
						fields. They should either be separate classes or subclasses, or even in the same
						system. It depends on actually how they would be implemented. The behaviors of the
						toasts may be different by this, so it could not be said in simple words just now.
					</p>
					<p> =04=
						Ticking of player entity should be entirely independent of UI ticking. The entity
						<i>is</i> a world object, but UI is a client side-only system. This is probably
						because menu interactions are handled in the entity ticking function, but it is
						not practical. Such parts should instead be handled by the <code>MenuManager</code>
						class or a similar class. This could also ensure class isolation and responsibility.
					</p>
					<p> =06=
						<code>World</code> would be instantiated and not a part of <code>core</code>.
						Also, levels would be managed by the world instances instead of being handled
						by other unrelated classes. Many several configurations and behaviors would not be
						hardcoded within program code, but with the assets, including the dimensions. Also,
						the world configurations like the seed and world name would be stored in an object.
					</p>
					<p> =06=
						All world-related randoms would belong to instances. These instances may also be
						replaced by the backend engine if necessary. Also, The fields for the level change
						listener, last world enter and exit time are not quite practical. The actual
						realization of dimension change would depend on the actual implementation, but not
						likely with a listener not implemented to do anything. Moreover, there is no need
						to compare and check the time when they could just be the initialization and
						termination, which could be handled by instantiations and instance destroys.
						Still, resetting sprite animations by this may not be a good way, but sprite
						animations should be handled in another way. Having instances would still be
						simpler than having the function of <code>resetGame</code>. Also, the logic
						is also problematic when both <code>Player#respawn</code> and
						<code>Level#add</code> are in the same block, so obviously the code should be
						more semantic, straightforward and logical. <code>WorldSettings</code> matches
						the logic, but the entire code is still not, unfortunately.
					</p>
					<p> =02=
						There should be a better way to handle world loading. For example, loading assets
						would have a progress bar, so as loading world. There would be loading sessions
						specified when starting the progress. Resource loading logic is outside the menus,
						so the loading code does not need to be inside the menus, but the loading menu.
						The loading screen is instantiated with the loading session, then the progress
						would then be updated and refreshed during the loading progress. There is no really
						need for the logger with the world name as it is already clear with just the
						reorganized class structures. Resetting world before initialization would not be
						needed if it is instantiated; when the world is loaded, the reset values would be
						even not used.
					</p>
					<p> =02=
						The exceptions used in world loading are quite reasonable. It is clear that when
						these rare exceptions occur, the entire operation must be interrupted or cancelled.
						This example is quite practical, despite the unorganized class structures.
					</p>
					<p> =08=
						The default uncaught exception handler should be set as early as possible. Then, when
						there is any uncaught exception, they could be handled well, and users could be
						informed properly. A lambda would be used instead of simply referring to a function.
						The content would be unique to distinguish from other caught errors or exceptions.
					</p>
					<p> =16=
						Resources or assets would not be loaded early as before canvas initialization, but packs would be loaded
						at the same time as vanilla assets.
					</p>
					<p> =03=
						However, probably only the loading screen, with
						probably a splash screen would be the hardcoded asset image embedded into the
						application. There would be a progress bar to initialize full loading of all parts
						after the appearance of the splash screen with a logo, like Minecraft's one, simple
						and neat but symbolic. Maybe there could be customized splash screen inserted after
						initialization just before the title screen or pre-, during or post-world loading.
						As for when to initialize tiles, entities and items, still a question, since it
						depends on how they are defined with registries later. For the title screen, it
						would be set only after the initialization, so the necessary resources would be
						ready first. If it is set to fullscreen on start, the window would be set to
						fullscreen when initialized, not that separated.
					</p>
					<p> =04=
						Users would have their client IDs, but detailed implementation would
						be decided later.
					</p>
					<p> =02=
						The entire save and load system would be separate, not simply just <code>Save</code>
						and <code>Load</code>. Every part is isolated, so as the timings, systems, and
						responsibilities of them. Preferences would be handled alone, without associated
						with other saves.
					</p>
					<p> =04=
						For server, the entire system would have to be planned. This includes serialization,
						routing and network communication. However, activities would have some treatments to
						prevent non-synchronization and data loss. There would be no really difference in
						implementation between single player and multiplayer for consistency and
						compatibility, especially in the server side or the server-client relationship.
						Actually, it may work like using numeric ID to identify the transmission data, but
						the protocol would neither be forward- nor backward-compatible.
					</p>
					<p> =04=
						When there is a server, analytics could be done. It includes counting active clients
						by the Launcher activities and the pings like in Minicraft+. Note that this is not
						telemetry, which collects even device information and usage reports. However, these
						data could still be collected <i>only when the user agrees</i>. Even the user decided
						to agree or not during the first launch (identified by local save data) of the
						application, the user could still toggle it in preferences. Both of these are
						optional, and there would be the corresponding terms made. Counting would be done
						on the server since it is just the database record, but pings would be kept
						anonymous. Both telemetry and automatic crash report transfers may not be anonymous,
						and some device information or account identifier would be included in the
						transmissions. Detailed implementation would be discussed later, but it is certainly
						something.
					</p>
					<p> =24=
						Colors, there is entirely no need to care about old-formatted color values. However,
						it could just use the similar functions, but there could be more colors, using less
						the tint function, or probably using other utility functions. For formatting codes,
						they would not be handled in <code>Color</code>, but another class handling display
						strings or whatever fits. In fact this kind of format may exist control characters
						that normally could not be typed, so they could not be used properly. The
						<code>limit</code> function is just the <code>clamp</code> function, repeated. The
						tinting functions and most other functions would likely be removed, but the lightness
						calculation could be reused, in somewhere.
					</p>
					<p> =01=
						<code>Dimension</code>, <code>Insets</code>, <code>Point</code> and
						<code>Rectangle</code> could be made into value classes, in which the fields should
						be immutable. Likely these classes related to graphics would be hidden into the
						graphics module, which would be only used by client side. There could be more
						functions to transform, operate or interact with these value classes. Also, Insets
						may not be really needed when there is <code>Dimension</code>, but probably the
						functions could be directly added to <code>Rectangle</code>.
					</p>
					<p> =01=
						If guessed correctly, <code>Ellipsis</code> is probably just the dotting animation.
						This style is mostly not used, since it is more tended to show more details and be
						more intuitive. Mostly, spinners, progress bars or more fancy animations are used
						nowadays. Ellipsis would not be used in the future. <code>SequentialEllipsis</code>
						seems to be moving a single dot per period; <code>SmoothEllipsis</code> seems to be
						looping dots like a loading progress bar without progress. The <code>DotUpdater</code>
						updating methods seem to be various but really unnecessary, it is still lacking
						information.
					</p>
					<p> =03=
						The <code>Font</code> class would be made into a single package but most likely just
						hidden within the graphics module. The <code>chars</code> would be fully configurable
						later by assets pack. Several drawing mode of text would be available, like plain,
						formatted, hard-/pre-formatted (styled). When drawing, an optional configuration
						object like the <code>FontStyle</code> could be passed as an argument, for background
						and foreground colors, and the rendering bounds? Actually for bounds, horizontal
						scrolling may be disused, but perhaps only the vertical values are useless. The
						ability to scroll entries horizontally would eventually not be implemented, but for
						displaying scrolling text only. Still, all the drawing modes could be combined to
						just set whether to enable formatting codes as the configuration attributes, since
						when nothing is set, it is fully plain; when something is set, it could be styled.
						The "redo" code may still be too complex in the system, so the stack class would not
						be needed. Width calculation, maybe using advanced looping, since invalid codes
						would not be used in formatting; probably display component architecture would be
						used to prevent this. Drawing centered may not be used anymore; drawing paragraphs
						would be quite advanced, so it would be higher level. For drawing styles, there
						could be paragraph alignment and shadows, but the current implementation of
						<code>FontStyle</code> is quite poor, and it could be replaced by using UI
						components.
					</p>
					<p> =09=
						Texture atlas could be implemented, especially when the engine is lower level, since
						it could improve memory efficiency for a mass number of sprites. All the textures
						would use the same set of atlases, in which a new one would be created only when
						the existing one(s) is/are full. However, a difficulty is that not all the sprites
						would be squares or even squares with the sides of powers of 2, a good algorithm
						would be required. A reference could be taken from
						<a href="https://www.david-colson.com/2020/03/10/exploring-rect-packing.html">
							this article
						</a>. Note that they would be mostly rectangles or squares, and all textures from
						all the assets packs would be loaded. <code>MinicraftImage</code> is just an
						alternative of the existing image classes with just a simpler class structure, but
						may not be used.
					</p>
					<p> =10=
						Darkness rendering would be advanced based on light sources and light level values
						saved in the chunk data. Rendering lightness would depend on the gamma value set.
						Mirroring settings could just be 2 separate boolean values, but sprite transforming
						would be realized in another way, probably by filtering function or something.
					</p>
					<p> =03=
						Anyway, the canvas would just handle the rendering results by the graphics elements
						from both the UI and the world. When it comes to the rendering engine, internally
						buffer arrays would be used. The rendering queues is quite a good idea compared to
						the idea in the past, it was used for rendering optimization. However, the optimization
						strategy by checking the clearing request is not that ideal in the system, since it
						could be an overhead. A better way is in fact to skip rendering when there is some
						places are intended to be hidden when it is in the rendering functions, but not by
						the processing functions of rendering requests. The responsibilities should be definite
						in fact. There would not be an overlay canvas just for rendering lights, but all the
						rendering would be done with just one canvas handled by the rendering engine for
						compositing all the graphics elements in one. The current way in <code>Screen</code>
						is actually more like a workaround to optimize graphics rendering, though not the
						best or the most practical in the industry. Among the rendering classes, only the
						sprite rendering and inverted color line rendering ones have not taken the advantages
						of <code>Graphics2D</code>, which could be optimized by hardware acceleration.
					</p>
					<p> =11=
						The <code>RenderingLimitingModel</code> is not a good implementation, actually. If
						the UI could be scaled and menus could be managed in a better system, there is no
						really need to stretch the menus or scroll the entries that hard. So, including
						<code>ScreenEntry</code> and <code>EntryRenderingUnit</code>, it is more like
						coding around the problem but not solving the problem, though it is just a badly
						looking workaround in the system. There should be a better way to do all these
						things in OpenGL.
					</p>
					<p> =09=
						As for <code>Sprite</code>, there would probably be a high level wrapper of the
						low level sprite instances. When sprites are loaded into the centralized texture
						atlas, each sprite corresponds to a pointer with some information locating the
						entire sprite pixels in the atlas. Then the sprites are saved into the registries.
						So, <code>Px</code> would also be replaced by the OpenGL functionalities.
					</p>
					<p> =09=
						The <code>SpriteAnimation</code> should really be the animated instances of the
						sprites with just a pointer with some little extra data. However, it may either
						be the animated UI components, or the animated texture parts. The sprite
						architecture should be similar to the specification as in assets pack. Also,
						the implementation of it internally is too complex, there is no need to align
						with the time outside, but just a simple tick counter by the ticking function.
						The borders should not be done here, but in another level. If it is just a
						simple extended variable instances from a sprite, there is no need for this,
						all the instances would be recreated, so no "relinking" is needed. However,
						these may probably just be remade from zero as a better solution.
					</p>
					<p> =09=
						These are probably a lot of messes in the codebase. The <code>SpriteManager</code>
						should be done by registries. If the skin is directly managed by the account,
						the in-game management of skins would be a lot simpler, without bothering with
						the records. The "missing" textures should be done in a higher level class than
						this. If the texture atlas system is done, there is no need to manage the sheets
						of all the sprites like this even loaded entire from the assets. The
						<code>SpriteMeta</code>, probably ignored, to be smashed and remade. The
						<code>SpriteType</code> logic is quite messy, they should just be registry things.
						Sprites and <code>SpriteLink</code>, quite complex though, too much. Why would
						there need to mirror the tiles respectively without mirroring the relative
						positions of them in a sprite? It is probably just because there is no a
						well-made filtering mechanism in the rendering system. OpenGL has these
						functionalities.
					</p>
					<p> =11=
						If ignoring all the subclasses, there are originally actually just <code>Display</code>,
						<code>Menu</code>, <code>Toast</code>, <code>TutorialDisplayHandler</code>,
						<code>RelPos</code> in the package of <code>screen</code> without subpackages.
						Display is literally monitor display, but not the screens which commonly mean
						the sets of pictures being shown on the window canvas.
					</p>
					<p> =11=
						Not too much to note on the title screen, but there could really be a background.
						For all the selectable entries, there could be highlights, but not using the
						arrows to simplify the appearance. On the title screen, there could be the logo,
						the menu entries, the version string, the splashes, the background. The splashes
						would not be hardcoded and conditioned, and thus fully customizable by assets
						packs. There would not be the need to show the help message on the bottom when
						mouse is supported, and enabled by default. The version string would be longer
						to add some more text. Probably the splash text does not splash, so named just
						"title texts". It is true that if they are made into components like how we do
						with AWT or Swing, there is no need to recalculate the positions or lengths
						again and again every frame, and the values would not be out of scope, for
						code quality it is beneficial. The code in the <code>init</code> function
						of <code>TitleDisplay</code> is not something should show up for the screen.
						The "Play" entry would become "Singleplayer" and "Multiplayer" 2
						entries, then "Settings"; achievements would not be there yet, so the entry
						would not be added. The simple screen like the 4 entries of the "Help" menu
						could just be a dialog menu, for simplicity. If the layout involves "clearing"
						the entire canvas or fully covering all the components in the back, it would be
						made as a screen, with all the content made as menus and/or components. When it
						involves a set of entries, the entries should be included within a menu. Then,
						the entries would be "Help" and "Quit".
					</p>
					<p> =12=
						If achievements become account-based, all the data would come from server instead
						of application assets. The implementation would probably like the Xbox achievements
						in Minecraft: Bedrock Edition. Anyway, the code, logic or parts that are not related
						to the UI should be separated from the classes, like the loading thing or achievement
						management. The achievement notification could be a lot better, like using toasts.
						The original unit class <code>Achievement</code> is quite light, with only a few
						fields, with other parts in the display class, but not organized well.
					</p>
					<p> =05=
						Toast is quite a good idea, but the implementation could still be improved. There
						are application (system) toasts and gameplay toasts, having similar properties, but
						they are used in different places. To make them separated, a better way could be
						putting application notifications in the bottom-right corner like the system
						notifications and gameplay notifications in the top-right corner. Players could still
						access the gameplay notification center in the inventory menu screens and the
						application notification center in the pause menu or any other screen outside game.
						The content should be formatted text, but somewhere, there could be bold title with
						details by an external function forming the resultant formatted text. There would not
						be too frequent for the instances, so the frames could be fully instantiated without
						using singletons. The constructor could be similar, that parameters are mostly decided
						by the subclasses with optional extra parameters. The sprite property could also be
						abstract property instead of constructor parameter with field, such patterns could be
						generalized as a code style. It accepts nullable for custom rendering, but should only
						with sprites for simplification. Animations could be supported, but it is another
						topic. <code>AchievementUnlockToast</code> is not that good usage. Still, there should
						be a better to handle the content, frame and animations.
					</p>
					<p> =13=
						For the <code>BookDisplay</code>, most probably the previous trial to implement the
						editable books, but the way to handle text fields could really be better. More details
						should be discussed later. Books without the title and page count are not books and
						should never use this class.
					</p>
					<p> =14=
						There would be an abstract class of <code>InventoryScreen</code>. All the menu
						screens containing the player inventory should extend the class. It includes the
						player inventory menu, crafting menus, container menus, but not the book screens.
						All the inventory menus would have the item counter, but different from the item
						list menu, which should really be used by the creative mode item list. The on-screen
						keyboard menu would be controlled by an input field instead of the parent menus, it
						also means flexible dynamic menu addition with certain priority should be supported.
					</p>
					<p> =14=
						For the screens like the <code>ContainerDisplay</code> with 2-sided menus, a better
						way is to use directional controls without "looping" through menus. However, if they
						are top-bottom menus, it would be different since they are likely more connected;
						still, tabs may still be enough. Note that the controls to select slots or move
						stacks across slots and menus would be available only when mouse is disabled to
						prevent conflicts with mouse controls, just like selecting tiles by keyboard. There
						would still be better layouts for these menus to work, but decided later. So,
						<code>getOtherIdx</code> does not really make sense here. Plus, determining controls
						by checking which menu the cursor is at, does not at all make this logical sense.
						It could also bother functionality changes. A standardized way should be supported.
						It should not be called "heaviness", but a better name or mechanism should be made.
						That color fading could later be realized by using the alpha channel.
					</p>
					<p> =14=
						It has been noted that the <code>CraftingDisplay</code> would be integrated into
						<code>PlayerInvDisplay</code>, which would later be renamed to
						<code>PlayerInventoryScreen</code>. Depending on implementation, there could also
						be subclasses of <code>SurvivalPlayerInventoryScreen</code> and
						<code>CreativePlayerInventoryScreen</code> or something, but surely to make the
						system more logically aligned with the code style. The recipe system would later
						be decided, so as the related crafting menus and recipe unlocking functionality.
						The way to get achievements is too hardcoded. The refreshing function is quite
						odd, but listening to inventory changes could be made if needed.
					</p>
					<p> =11=
						<code>Display</code> should surely be an abstract class renamed as
						<code>Screen</code>. However, <code>parent</code> should not be handled here
						and instead by the manager only. Some several functionalities would be supported
						to enhance the features used by other menus associated with the menus. There
						would not be <code>clearScreen</code>, and <code>canExit</code> may be replaced
						by an overridable function, or probably a screen handle callable by the screen.
						This class would become like a panel or something. <code>selection</code> of
						menu would only be useful for keyboard controls, but likely tabbing would do
						this. For components to be selectable by using arrow keys, they could be aligned
						using layouts like AWT does or relative positions, like grid layout and border
						layout. There may not be the need for <code>onSelectionChange</code>, but it
						may be used if it is used for accessing hidden menus which could also be
						accessible with mouse hovering, only if it contains only selectable component.
						This rendering function is no longer applicable, and rendering depth should not
						depend on selection index.
					</p>
					<p> =12=
						There could still be the <code>HowToPlayDisplay</code> screen. Firstly, the
						rendering of keys could be enhanced with using images, which are the mapped
						keys, but not the names of the mappings. All the paragraphs would be put into
						a single translation entry to simplify this thing, but there may be ignorable
						odd double line breaks between paragraphs. There would be actually 3 types of
						controls: Keyboard Only, Mouse &amp; Keyboard, Controller. No fallback, so when
						any controller is disconnected, keyboard would still not usable, unless it is
						"Controller &amp; Keyboard", with the pattern that "major-first-minor-second".
						For every set of controls, there would be a guide, with topics in the subtopics
						under each setting of control. If there are guides without <i>any</i> control,
						they should be placed aside the control guides. Usage guidelines for each set
						of controls could be different, but most of the basic functionalities would
						still be usable. Control guides should be put into control guides; general
						gameplay guides should be put into general guides. However, advanced guides
						would not be placed here, but instead other places, like with a wiki. The
						layout of this screen may refer to the one in Minecraft: Bedrock Edition.
					</p>
					<p> =15=
						There would not be the <code>InfoDisplay</code>, but there could be statistics
						in the pause menu. Each player would have their own set of statistics, but not
						for the server or the world. The world information may not be seen here, but
						perhaps other places.
					</p>
					<p> =14=
						The <code>InventoryMenu</code> could have the holder, but not limited to entity.
						The inventory content would be linked or associated to the holder's inventory.
						Any update made in either place would be reflected to the another. However, the
						content alignment would not be needed, thus the <code>slot</code>. Each slot in
						the menu would correspond to a slot of the actual inventory. There would not be
						the creative inventory handled here as mentioned previously. A listener would be
						registered to the inventory if they are inventory slots. If they are temporary
						slots, like in the crafting menu, the listener would be registered in the menu.
						However, since inventory slots may still be updated without interacting with the
						menus, the listener related to the inventory would probably be registered directly
						into the inventories, by the holder or something. Item stack operations could be
						handled by the item list menu, but well-formed structure to handle both the items
						in the non-inventories and the stacks in the inventory slots should be both handled.
						There might be a wrapper handling this, but the detailed implementation should be
						discussed later. There may not need the <code>refresh</code> function for updating
						the menu frame. The description menu may be later made as a tooltip or a separate
						menu aside.
					</p>
					<p> =11=
						Each menu may handle the content in a different way. There may not be entries,
						<code>ListEntry</code>, but components, so there would also not be
						<code>removeSelectedEntry</code>. However, the implementation might be similar
						to AWT or Swing. The way to handle stacks in <code>InventoryMenu</code> is not
						perfect.
					</p>
					<p> =11=
						When <code>ItemListMenu</code> becomes using slots, there would not need the
						display length thing. Also, there is no longer the need to "cut" or align the
						entries, so the positioning parameter could be dropped. The way to build the
						menu would be more flexible as components than using like this way, including
						the padding.
					</p>
					<p> =02=
						The <code>LevelTransitionDisplay</code> would just act as the UI. The process
						of dimension change would be handled in the manager. There is likely not the
						definite progress, so seemingly the loading screen would appear a standard
						background with a message. Also, the "level" which then be dimension may not
						be loaded in advance, it needs to wait for the loading completed at least for
						the targeted chunk.
					</p>
					<p> =02=
						The <code>LoadingDisplay</code> would become <code>WorldLoadingScreen</code>,
						which is not controllable by the escape key. Since the world is loaded chunk
						by chunk, the progress would be separated into segments with each corresponding
						to the state of a chunk. Corrupted chunks and regions would be regenerated with
						backups of original data made, such chunks are deleted from the loaded chunks.
						If there is any missing chunk at or around the spawn point, they are created
						and monitored by <code>WorldCreatingScreen</code>, which would also be used
						by the <code>WorldCreateScreen</code>. The current implementation of
						<code>LoadingDisplay</code> is quite messy. Loading would not be handled by
						the screen but the manager class, so the exceptions would not be caught there,
						and thus the menu dialog would be launched by the manager. About auto fixing,
						it would be handled directly in loading schemas, as they would be assumed to
						be bugs previously reported and resolved. The message popups could instead be
						application notifications. The progress handling would be quite special.
					</p>
					<p> =11=
						<code>Menu</code> would become more general, as a component container. It
						would not contain any entry by default. If there is any container-like
						component managing entries like <code>ListEntry</code>, they would be other
						cases and handled in another way. Importantly, an abstract menu would basically
						not have any property like size, position, title, spacing, frame, selectability,
						rendering and searching, even no content. Better may be making the menu
						containing a container passed into the constructor as final and protected, with
						delegations, and menus are managed as a separate system than components. Then,
						<code>Screen</code> would be the similar case, with a difference that only
						<code>Screen</code> could contain any <code>Menu</code>, but not class itself.
						The copy constructor and builder patterns are quite messy here. The searching
						function would be provided separately when the container needs it, which would
						be powered by a input field and the searching context, working together to
						give the filtered result, without that fragile highlighting and meaningless
						scrolling functions. Searching is performed when <kbd>Enter</kbd> is pressed,
						but not every time the field is updated, and pressing <kbd>Escape</kbd>
						deactivates the field without performing searching, <kbd>Enter</kbd> also
						deactivates the field. Rendering of components and such things would be based
						on relative positions, so there is no need for the translating functions.
						There might be "visibility". Some containers may have listeners supported.
						Scrolling animation really complicates the code. There would be no need to
						update and remove entries, as well as the builder and <kbd>MenuListEntry</kbd>.
					</p>
					<p> =11=
						Only the top-most screen is interacted. Moreover, if the upper screen intends
						to cover the lower screen(s), rendering of the lower screens is skipped. The
						gameplay canvas would also be a screen, so that it could also be managed by
						the <code>ScreenManager</code>. When the gameplay screen is added, it would
						be placed as the lowest screen, and all other screens are dropped. Also, when
						any of the world loading screens are initiated, other screens are also dropped.
						Components may not take the menu or screen handle when ticking, but menus would
						always take the screen handle passed to screen ticking. The handles and the
						functioning would be handled directly in the screens and menus, even locally
						defined components. Some menus may be with definite frames, but not all.
						Rendering functions are all present in both menus, screens and components.
					</p>
					<p> =15=
						For the other usages of <code>MessageDisplay</code>, there are only the link
						error message and resource pack description. The former could be replaced by
						application notification and the latter could be combined into the main menu
						layout or replaced by tooltips, so this class could be dropped.
					</p>
					<p> =04=
						For <code>MultiplayerDisplay</code>, there is nothing valuable for reference.
						However, it is worth noting that logging in should be done by the Launcher,
						and the client ID, user ID, authorization token and ID are all sent by launching
						arguments. Some more data would be fetched by the application by these data.
					</p>
					<p> =13=
						There is no the real need of <code>PagedDisplay</code>. It could really be replaced
						by using a scroll pane, which is even more easy-to-use than pages, unless they
						are really books, but not the case. Not much to notice, this class could be dropped.
					</p>
					<p> =04=
						For the <code>PauseDisplay</code>, there would be <code>SingleplayerPauseScreen</code>
						and <code>MultiplayerPauseScreen</code>. A singleplayer game or the host of a LAN world
						would use the singleplayer version while a multiplayer game would use the multiplayer
						version. A client connected to a LAN world is also regarded as multiplayer game. The
						title of the menu would be "Game Menu". Basically, there would be "Back to Game",
						"Settings", "Statistics", "Advancements". For singleplayer one, there would be "Open
						to LAN", "World Options" and "Save and Quit"; for multiplayer, there would be
						"Disconnect", but more functionalities may be added by plugins or mods. There is an
						uncertainty that there would be a "Save" or "Backup" option for singleplayer, but a
						more convenient-to-implement way is only using commands, just a problem that either
						saving or backup would require a complete suspend of gameplay for synchronized game
						data being saved well. Saving and backup could be performed only when all the game
						ticking threads are suspended on the server side, so this should be handled by the
						server internal part, but not what should be handled by the in-game commands. For
						dedicated servers, there are server commands, but there are no such things in
						singleplayer. As for the scope of in-game commands, the topic would be discussed
						later. The only way to implement is only via the pause menu, so discussed later.
						The background of the pause screen would be the dimmed gameplay screen, but the
						gameplay screen would not be interacted, though rendering continues, even clicking
						mouse on the dimmed screen would not close the menu.
					</p>
					<p> =11=
						The <code>PlayDisplay</code> has already been deprecated. The 2 entries would directly
						be merged into the title screen as mentioned.
					</p>
					<p> =04=
						For the <code>PlayerDeathDisplay</code>, it would be <code>PlayerDeathScreen</code>
						with the dimmed gameplay screen, similar to the pause menu. However, the gameplay
						screen would be frozen to the last frame the player died. The title would be "You
						Died!" in addition to the death message. When the player died, the entity does not
						exist in the world, but the player <i>is still in the world</i>, with the status of
						not being spawned. Therefore, the player could not receive any activity from the
						world. In that status, the died player could only either respawn or quit while the
						world is still running. If immediate respawning is enabled, this screen is skipped
						and the player respawns. The quit button is the same as the one in the pause menu.
						Player could not open any other menu while on this screen and there would not be any
						other information shown.
					</p>
					<p> =14=
						Some details of <code>PlayerInvDisplay</code> may have already been mentioned
						previously. The creative mode item list menus would be accessed in another way,
						either tabbed or made into other menus aside. For the other parts, it would be
						as what mentioned. Anyway, the selected slot would be bordered or highlighted,
						and the selected stack of item would be at the cursor, hovering above the
						inventory menu(s), with the original slot being empty or as a reference of the
						source slot. There would not be the help text. Then, it would not be using this
						way to hide the item list menu.
					</p>
					<p> =15=
						For other usages of <code>PopupDisplay</code>, some of them could be replaced by
						tooltips or full-canvas options dialogs or screens. Some as submenus would be
						implemented like simple panes with just a few components added, similar to anonymous
						classes. The ones with just messages could be replaced by notifications. Some with
						just simple buttons of options could be made by a class named <code>OptionMenu</code>
						or something else composited of a display message content and options with name and
						fallback. There may not be the need to have a confirmation popup on quit. As for the
						options dialog menu, if it would not exit or change the current screen, it could be
						full-canvas; otherwise it could be with a menu frame. Full-canvas screens could be
						with lightly dimmed and blurred original screen or with a background image, along
						with its components. As for listening key sequences in the settings, a non-full-canvas
						menu or a banner could be shown to indicate that it is listening key inputs and what
						keys are currently pressed. The resultant sequence would be at the moment before any
						key has just been released. For example, the confirmation dialog menu of resetting
						all key bindings would be framed. The styles or appearance of the frame would be
						decided later. When there are buttons, it would not rely on hotkeys and this structure
						could be discarded, even for keyboard-only controls, with just a few simple options.
						It could also make use of the screen resolution by fitting options horizontally.
						Even using select entries would be easier to use than listening keys. Note that the
						options dialog menu would not be exited by <kbd>Esc</kbd>, and the options must be
						used instead. The on-screen keyboard (OSK) would not be handled specifically here.
					</p>
					<p> =12=
						For <code>QuestsDisplay</code>, the management part could be separated like how
						advancements should have been done. This kind of quest tree display would be quite
						complex, so keyboard navigation would be available only on keyboard-only mode; or
						the mouse should be used to drag. Like mentioned in other mechanisms like OSK keys,
						the components could be linked. There are various ways to display the node description
						in the tree layout: the first way is using tooltips; the second way is showing the
						content in a separate menu with the hovering node, empty if nothing hovered; the third
						way is to select the node on press and show the content in a separate menu. It would
						depend on whether there would be features supported here. As for the JSON structure,
						it would not be important when it would no longer be formatted in this way as sources.
						Full refreshing functions like <code>refreshDisplayableQuests</code> should only be
						invoked only when they are loaded or something, but not every time some elements are
						updated, which should always be done in sync with any related activities. This includes
						<code>reloadEntries</code>, though the data should not be updated in real-time even if
						they are changed, instead should be the snapshot at the time accessed for simplicity
						and also consistency. The inner subclasses of <code>Display</code> are quite complex, but
						they could just be made as submenus.
					</p>
					<p> =12=
						In the structure of quests, they are organized as series. There is no singleton quests
						but series of quests. A series includes several quests, which may be unlocked in
						sequence. When showing the menu list of series, they could be listed on the
						left-hand-side and put the tree layout on the right-hand-side menu, making use of the
						screen. If there is description for the series, it would be put on the right-hand-side,
						on the top or on the bottom, outside te tree. Certainly, while there would be 2 separate
						systems of quests and advancements, quests would not depend on the system of advancements
						but the more abstract structure. In abstraction, they are called "Progression Systems".
						Locked quests would always be hidden to prevent spoiler, but advancements may be hidden
						depending on the levels. The implementation of <code>SeriesQuestViewerDisplay</code> is
						really complex, if there is a component supporting drawing graphics in shapes this could
						be a lot simpler, in addition that the nodes could still be boxes of components. Still,
						if the components could be shapes, there is even no need for the graphics component,
						simply placing them in the component pool. Making rows and columns while they are
						unnecessarily like that would be complex, but making linking like elements in a linked
						list should be enough. That means there would also not need the map of quest
						relationships when they could just be put into the quest node component instance. Auto
						scrolling would be used only for keyboard or controller controls, or mouse dragging would
						be used instead. If the quest manager is instantiated, there is no need the functions of
						<code>resetGameQuests</code> or <code>load</code>, and saving would be handled by a world
						save manager. There are no need separated tabs for unlocked and completed series, but
						probably a select dropdown for showing all, only unlocked or only completed series, and
						the display menu on the right would be empty if no series is selected in the tab.
					</p>
					<p> =14=
						A new recipe system would be made. The recipe menu and crafting menus would differ a lot.
						The most important part is that it would become an inventory menu with the player storage
						space shown on the screen.
					</p>
					<p> =01=
						There may be different sets of directions or positions, but they should be managed in a
						standardized way, with their enum classes. For example, there would be sets of 2, 4, 5,
						8 or 9 directions. <code>RelPos</code> is an example of a set of 9 directions in a
						rectangle. A border layout would use a set of 5 directions. <code>xIndex</code> and
						<code>yIndex</code> should rather be computed on demand according to the natures of
						<code>ordinal</code>. To be value-safe, functions like <code>getPos</code> would be
						avoided, and <code>getOpposite</code> would use switch-case or when instead. If there
						must be a value of anchor based on <code>Point</code> and <code>RelPos</code> specified,
						a dedicated class of <code>Anchor</code> could exist.
					</p>
					<p> =14=
						The <code>RepairBenchDisplay</code> would still be an inventory menu. Actually, if
						possible, storage slots would be recommended over temporary slots, which are what
						<code>RepairBenchCarrier</code> is using. This style and approach is quite new to
						this codebase, but the <code>SlotEntry</code> would not be an entry later, just
						simply be a slot. Every menus handling stack transfers in their places, it is quite
						repetitive whilst could be simplified by an improved model in fact. The component
						of a slot would associate with a backing slot instance. If they are just buttons
						and slots, disabled buttons and empty slots may still be selected, but just could
						not be interacted. Storage spaces may have attributes or properties, that could
						define what kind of slots they are, like crafting inputs, products, and so on. The
						durability of fishing rod could really be implemented to simplify the situation.
						The functionalities of slot entries would mostly depend on the natures of the
						backing slots. The <code>RepairInfo</code> is actually a context generated by the
						input items. The existence of the carrier is just to draw the scope within the
						display class. Having a leading space in the string for positioning is somehow
						problematic, but common in this codebase. The slot labels could actually be
						replaced by intuitive graphics. The function of <code>onAction</code> is used
						only once in a specific scope, so it could instead be a lambda. That "checking
						again" may be turned into assertions since it is intentional. Although stack
						movement would primarily be specified for the destination, mouse scrolling or
						L1-R1 switching on a slot may still be supported and act like
						<code>addToCarrier</code>, probably directly operating on the stack. If they
						are storage slots, the stacks would not need to be dropped on exit.
					</p>
					<p> =16=
						The resource packs and similar things would no longer rely on the directory
						structures. There would be several categories of the assets. The only supported
						version of the packs should only be the one the version of the application was
						designed for, and the older packs may only be loaded with minimal supports
						where possible. As for the vanilla assets, if all the assets are configurable,
						they should be packed as one and either embedded in the binary or as an external
						asset, but modifications to it is disallowed and thus only loaded once on start.
						There is no longer the need to traverse the embedded assets. The screen would
						still be 2 tabs with the left unloaded and the right to load. With a higher
						resolution, there is really no need to combine them into one list while it could
						reduce the discoverability of the list. Only the brief description of the packs
						would be needed, so the screen does not have to be detailed. The watcher would
						monitor all the packs. When leaving this screen, all the packs are loaded into
						memory, and the packs would not be locked, so all the packs except vanilla
						assets would be reloaded even if there is no change while on this screen. For
						the list entries, if there are new items added to the list, the selected one
						would be kept selected but shifted, and the selection would be removed if the
						entry is removed; the list entries would not be said to be selected by the mouse,
						but for the other controls. The file watcher, would be itself as a utility class,
						so would not be the inner class of the display class or such. On the other hand,
						they are locked to ensure it would not be modified during loading. If they are
						keyboard or controller controls, the packs could only be moved while selected.
						Then, the list entries are also likely linked. For reading the information of
						the pack, "soft read" lock would only be needed, the dimensions of the logo
						would not be limited, but there are always the optimal ones. This stream handling
						part is actually quite low level. There would also no need for the filter to
						get the assets content. Depending on the assets, mostly only the embedded assets
						may use the <code>readStringFromInputStream</code> function, but not a must. The
						metadata would no longer be a single file, and most content may not use the JSON
						structures.
					</p>
					<p> =16=
						The steps to load packs on start during initialization would be:
						<list>
							<li>Load directory for packs.</li>
							<li>Match packs with preferences.</li>
							<li>Select matched packs and ignore others, warnings may be emitted.</li>
							<li>Hard lock all the packs including vanilla assets.</li>
							<li>Validate vanilla assets with a checksum, an error may be emitted.</li>
							<li>Load all the packs in order into the memory.</li>
							<li>Release all the packs.</li>
							<li>Finish initialization.</li>
						</list>
						Note that the assets for the loading screen would be embedded, but it is possible
						that there could be a "booting" screen configured after loading.
					</p>
					<p> =16=
						The steps to load packs after saving the pack preferences would be:
						<list>
							<li>Unload all the assets except vanilla assets.</li>
							<li>Select matched packs and hard lock packs, errors may be emitted.</li>
							<li>If reversible errors are emitted, return to the pack list screen.</li>
							<li>If any pack is updated during the process, return the screen.</li>
							<li>Load all the packs in order into the memory.</li>
							<li>Release all the packs.</li>
						</list>
						Obviously, the way to manage the vanilla assets is quite different from custom
						packs, but the format and specification would still be the same. The part which
						matters would only be how the pack manager works to align with the standard system.
					</p>
					<p> =16=
						Since it would involve different stages for initialization and configuration, there
						may not only be the single manager for the packs. Post-construction initialization
						would not be design-safe, so the stages may be separated into several utility parts
						for the entire pack management system. Individual packs would be on their own, but
						the workflows must be safe enough as designed.
					</p>
					<p> =16=
						For pack loading, all the parts would just be handled by a function with the manager.
						Skins would be handled separately from the assets. If assets loading is handled in the
						lower level, the processing code may not be here. As for loading packs, the exceptions
						would only take for a single pack, but the entire loading process would be stopped for
						strict mode. Also, the compatible mode would skip some unimportant exceptions and allow
						loading old versions.
					</p>
					<p> =04=
						Since skins would be handled by the account system on the platform, they would not be
						handled by the application. There would also not be the screen to preview or configure
						skin in game. Then, they would not be stored as associated textures, and thus directly
						as player data. The skin data would be sent only from the server to the client side,
						comparison would be done on the client side. The watcher thread would no longer be
						needed. The Mob Sprite would be a huge difference.
					</p>
					<p> =15=
						The <code>TempDisplay</code> is quite useless. If a URL is being opened in browser,
						a confirmation popup would always be shown. There is no actual need to automatically
						close the screen noting opening in browser, but immediately close the confirmation
						popup menu.
					</p>
					<p> =12=
						Tutorials should be reworked. However, they could just be in the How to Play screen
						or as guides configured in the menus, which could be referred from RimWorld. As for
						completion detection, those may be detected in realtime, including the interactive
						elements and input events. The one in Minecraft is not valuable for reference here.
					</p>
					<p> =07=
						As for the world names, there should be no limitation. Therefore, the directory names
						of worlds would be differently handled, by a randomly generated character table of
						alphanumerics by indices, with an incrementing counter. Both the table and the counter
						are stored as "internal" data of the client application. In normal operation, the
						directory names must not be modified as there would be an internal table storing the
						directory names as the identifiers for some preference-related local user data, like
						the last played world. Since there is a chance that an unexpected collision occurs,
						so a warning would be emitted and such string would be skipped. Overall, the string
						would seemingly be incremented as 62-based and likely random. On the other hand,
						server data are not stored on the client side, but sent on demand, only the server
						configurations and primary metadata are stored in client application data. Then, there
						is totally no need to check the names with any regular expression. Players are more
						advised to access the world directory via an application rather than a filesystem
						browser, and edit most files with advanced editors. This way, players must use the
						application to import or export worlds, even making backups, the launcher might also
						support such operations. Even worlds with duplicated names could exist, so it is
						advised to make the name identifiable and unique, a warning would be shown if such
						scenario occurs, but the name would still be saved as is instead of being modified
						to become unique.
					</p>
					<p> =07=
						The <code>WorldCreateDisplay</code> would be renamed and accessed from the world list
						screen listing local worlds. The screen would only handle the inputs, all the
						user-specified settings. If some of them are empty or remained as "default" without any
						customization, the default values would be filled during the initialization of world
						creation process. The seed field would accept any character but further hashed with
						a custom hasher even they are numbers, so an option to input real numeric seed would be
						provided near the input field. If there is any field containing illegal characters or
						unknown values, they would be marked as "unparsable" and the button to complete would be
						disabled. There is also no need to show what name would be saved eventually. The setting
						fields would be initialized only on this screen, so no any settings are saved after world
						creation, and they would not be saved as global states like the <code>Settings</code>.
						The <code>WorldSettings</code> class would be a record class storing all the input values,
						declared not in the screen class.
					</p>
					<p> =07=
						In the world list screen, there would be several operations available, including importing,
						exporting, copying, deleting and creating worlds, where exporting, copying and deleting
						could only be done on existing worlds. Basically, the <code>WorldInfo</code> class might
						be just the similar record class with fewer information, but with an addition of world
						size on disk. The icon of world can be customized but the default icon would be the same.
						Note that the world version shown would not be the actual logical data version but the
						display version that the version of the game last accessed. The directory name would not
						be shown however, but the user could open the world folder via the browser by a button,
						labelled "Open Folder", or as a button on the selection, so that there is no need to show
						disabled buttons. Then, the user has to press the play button on the selection, although
						there might be optional quick access by double-clicking the entry, disabled by default.
						Since the screen would be a lot finer and larger, the world information would be shown
						within the entry instead of the separate menu. If there is any data stored a world key
						which does not exist, such data would become unknown. While the screen is opened, the
						watcher thread would keep tracking of the changes notified by the filesystem and the
						operating system. While there is an operation emitted in the screen menu, the world
						data of the selected entry would be sent as argument, without using the static fields.
						Too much duplicate code in the ticking method, but many parts could be separated and
						simplified.
					</p>
					<p> =11=
						Many screen menus would not allow using <kbd>Esc</kbd> to return to the previous screen.
						In such cases, if the screens are allowed to be returned, a dedicated button would be
						available. This could prevent user losing any progress easily.
					</p>
					<p> =07=
						The process to load world information would differ a lot from the original one. Also,
						having methods of <code>setWorldName</code> and <code>hasLoadedWorld</code> is really
						weird. <code>getValidWorldName</code> would not be needed. To simplify the process,
						copying world could just be a simple "duplicate", appending "Copy of" in the front of
						the original world name. User has to edit the world to change the name afterward, or
						the user could enter a different name than the default given name in a similar dialog
						like the one in IntelliJ.
					</p>
					<p> =17=
						The Player entity is actually a living entity, but different from mobs (or a different
						name for accuracy). The only general difference is that the controls are handled and
						implemented differently. This way, the entity system could be more generalized into
						various elements without having to bothering to making more subclasses of entities and
						implementing similar behaviors. Since the take action would be handled by a player
						ability, this would not be an available part of a general entity. A new tree of entity
						types would be proposed later after this report. However, there are some general concepts
						should have been noted:
						<list>
							<li>
								In the following context, the details will be explained by: "actor", who act or
								apply an action on the target; "target", who received an action from the actor
								as an event; "controller", which controls and decides the behaviors of an entity
								depending on various events, different controllers may exist in the same entity;
								methods in code will be described as respective events; the context of all the
								states in a world will be described as the global states.
							</li>
							<li>
								Since anything is processed on events, all the related actions are acted only
								when the events are emitted and started being processed, including the regular
								ticking and the occasional updating events. While there are no such spontaneous
								events of attacking and using, but the receiver interface of hurting or damage
								receiving events. If an entity or a mob actor likes to emit an attack or use
								event on the target, the event is then emitted during the main event, forming
								a tree-linked relationship between the events. The passive outcomes initiated by
								the master event, relying on its provided arguments, along with the common states
								seen by the most parts.
							</li>
							<li>
								If the attack event is a passive event triggered by the controller, the event
								should only take its responsible part to respond to the master event with provided
								arguments and the given global states. The more important part is that an attack
								initializing event is simple and only calculates the basic elements of an attack,
								while the precedent parameters are given by the controller, so there should not be
								the general event responsive in the main body of an entity. The attack action may
								however be managed by a separate controller, and the counterpart of the initialized
								attack action should only handle and response to the event only, but not limited
								to the indirect states affected by the event. Thus, there may only be just the
								hurt receiver event in the main body of an entity to be triggered by the damage
								source.
							</li>
							<li>
								Also, for use actions, there might be something to note. There could be "use" event
								with the subject of a tile or entity, and the "used on" event with the subject of
								an item. By default, the target is the subject, but the subject may change depending
								on which one is the subject depending on the event. Unless there comes to a new
								solution solving the ambiguity, this use action could still not be split. However,
								the middle mouse button could indeed be used for this, detailed resolution may
								be discussed later.
							</li>
						</list>
					</p>
					<p> =18=
						When an entity is added into the world, an identifier would be passed into the constructor
						of the entity. The identifier would be unique to the world and thus readonly. Since the
						removal of entity would be handled on each tick of world updates and there would not be
						a field saving the boolean whether it is removed, everything would still be taken into
						account without knowing whether the entity is still in the world next tick, it is advised
						to avoid pure incoming references existing more than a tick on the target entity. The
						models of entities should be hidden and immune to direct external impacts but rely on
						internal states. There might be a record class of <code>EntityPrototype</code> before
						the construction of entity, by storing all the controls. By the way, entity color is
						really pointless.
					</p>
					<p> =09=
						The rendering part of entity is mainly responsible by the texture models, but the
						appearance may be different depending on the entity states and properties. For this,
						an extra control element might be better than using method overrides. Moreover, the
						interactive models are handled differently and only affect physics, while both are
						stored in the entity. Still note that the interactive models should be simpler than
						the texture models, since textures may be preloaded as atlas.
					</p>
					<p> =19=
						It is not a good way to have both <code>isSolid</code> and <code>blocks</code> to handle
						collision conditions. A better way may still be having only <code>blocks</code> and
						assessing entity data on collision if necessary.
					</p>
					<p> =17=
						The properties of whether the entity can swim or walk on anything should only be handled
						by the AI moving controls, given to their usages. Also, visual "on fire" would be a
						special temporary metadata property of an entity, but the entity may reject the property
						when appending. For the damages of fire or burning, they are handled by the damage
						sources as the arguments. For the controls, there might be a method that even mods could
						add by the interface with the default values; this may require Typed Anchor Dynamic
						Mapping, which will be proposed later.
					</p>
					<p> =17=
						For the <code>isAttackable</code> methods, since an entity still blocks the interaction
						no matters what, there should be no necessity for the extra checking method before the
						actual functioning method. In fact, if they are the entities that are not supposed to be
						interacted, the action should act like there is nothing interacted. The similar concepts
						are also applicable on both <code>isInvulnerableTo</code> and <code>isUsable</code>, so
						it could eliminate the risk of check-and-use inconsistencies and
						simplify the API for callers. Damage handling should also be handled by controls.
					</p>
					<p> =19=
						Movement would mostly be tackled by the physics engine, so there is no need to worry about
						the <code>move</code> methods for entities. However, the velocity and acceleration
						controls matter, thus they would be managed by move controls. The actual implementation
						for the algorithm used sub-stepping by breaking down the movement unit by unit, but
						unrealizable for a decimal coordinates system. Before the algorithm was implemented,
						tunneling actually occurred for increased speed, which had also been reported in fact.
					</p>
					<p> =18=
						Despawning would also be handled by a dedicated control. This way, if the entity does not
						support despawning, the control would be null instead. This also includes the call when
						the entities are removed or killed. Moreover, the methods for "delegations" of controls
						could actually be inline functions as they are just helper methods, added that controls
						could be dynamically added, so the scopes and ranges of them could not be limited. The
						same as <code>ItemHolder</code>. Control classes may also add extension functions to
						master classes like <code>Entity</code>.
					</p>
					<p> =06=
						With the new entity system, an entity cannot be barely removed from a dimension but killed.
						However, the entity could move to another dimension by altering the coordinates, which
						cannot be empty. The <code>getClosestPlayer</code> method should be a helper method that
						generally could be used, so even commands may use that. Other methods may be kept.
					</p>
					<p> =01=
						Both <code>Tickable</code> and <code>ClientTickable</code> have no use. There is no point
						to have them, so the reason behind this cannot be found. The <code>Direction</code> is
						actually the entity activity direction, but when it would not be 4 or 5 only, the enum
						would become insufficient. For direction system other than the compass directions, a
						vector in spherical coordinates with a unit length would be used.
					</p>
					<p> =21=
						Having <code>ExplosionTileTicker</code> as the animation is actually a bad idea. In fact,
						using tiles as the animations is a bad design idea itself already. Given the tile system
						that ticking of tiles are random, but tile entities are ticked regularly, the transitional
						state as a tile could interfere the design consistency of the entire system. Apparently,
						other than having a transitional tile, particle animations with immediate tile destruction
						are a more consistent way to the system. <code>ExplodedTile</code> should be removed.
					</p>
					<p> =19=
						The mechanisms and situation of <code>Arrow</code> has been explained before. When there
						is the new entity system, this could also actually be solved way more easily, including
						the collision detection. Also, no idea why the check of tile with ID 16, which is lapis
						ore?
					</p>
					<p> =19=
						Although <code>ItemEntity</code> itself would not have acceleration, initial velocity and
						frictions on the ground could still be applied. Most likely, the code has messed up what
						"velocity" and "acceleration" actually mean in mechanics. Ideally, each Item Entity
						should only represent a stack of item(s). There could also be two separate properties for
						the total time lasted and the remaining time before deletion. If the remaining time is
						null, the entity would never be deleted. The two fields for synchronization are quite
						meaningless. When there is the 3D world system, there is no need to solely calculate
						the vertical motion of the entities for animation, as well as the shadows, which could
						also be standardized across different entities. The class would provide a factory method
						to initialize the entity, instead of by <code>Level</code>. However, the initial
						direction and velocities of the entities should not be determined within the
						constructor but with factor methods that handle differently for dropping items and loots.
					</p>
					<p> =20=
						It is still an uncertainty of how items should be dropped when the player died. A
						discussion has been held for this topic, but different implementations come with
						different properties. The actual implementation would eventually be considered by the
						theme of the game. When the game's goal is to make the mechanisms more realistic, death
						drops would likely be implemented like in Rust, with a dead player body included with
						inventories. Then, the idea of <code>DeathChest</code> could be dropped.
					</p>
					<p> =22=
						Pushing of <code>Furniture</code> should be handled more wisely when there is the
						decimal coordinate system. Light thing may still be entities, but heavier things like
						<code>Furnace</code> and <code>Oven</code> would become tiles. The item sprite should
						not be stored in its entity instance. Using reflection in copying could be a fragile
						design.
					</p>
					<p> ====
						If there is something that runtime lists may not do much, static fields may actually
						more debugging-friendly.
					</p>
					<p> =04=
						If the new sleeping mechanics is implemented, there would be
						no need to count players sleeping. Also, there is no need to store the color enum in
						<code>Bed</code> instances. Items, entities and tiles would not have display names
						given in their constructors, but the translation keys and registry keys. Moreover,
						removing the player entity from level when sleeping is quite an illogical design.
					</p>
					<p> =22=
						Also, having <code>die</code> in Furniture is quite awkward.
					</p>
					<p> =20=
						Inventory randomization should not be put in <code>Chest</code>, but the places that
						handle generations. The container inventory would be publicly visible as it would be
						a public interface access.
						When there is no longer the dungeon, the mechanisms of the entire dungeon could be
						ignored, since they could be better written.
					</p>
					<p> =18=
						As for <code>Composter</code>, there could be more details in the mechanisms. It may
						still depend on the direction of the game, but most likely, everything could be harder
						and more complex.
					</p>
					<p> =14=
						All the crafting mechanisms are too similar, and more differences could be made.
					</p>
					<p> ====
						Also,
						this string analysing way is too error-prone. In fact, we should rather let compiler
						complain than allow runtime errors or subtle bugs to occur, and reducing the amount of
						code does not mean improving runtime performance, even using loops to reduce the parts
						of code does not mean the method is wise or the developer is smart.
					</p>
					<p> =10=
						<code>Lantern</code> could be just one of the advanced artificial light source options.
						The way to handle lighting could be really better. The current way does not handle light
						blocking by objects, but actually gameplay experience could be enhanced if it could be
						done. The way to if-else chain the enums could be changed into switch-cases if the JDK
						version could be raised, but in Kotlin, <code>when</code> could be used.
					</p>
					<p> =14=
						The code structure of <code>RepairBench</code> is actually neat. There could be slots
						stored in the entity.
					</p>
					<p> ====
						Actually, in the structure of Kotlin, some constructor parameters could be simplified
						to abstract properties. Also, not everything has to be in the constructors but the
						factor helper methods.
					</p>
					<p> =14=
						Still, the <code>RewardChestInventory</code> could be
						generalized to a class next to the <code>UnlimitedInventory</code>.
					</p>
					<p> =18=
						The mechanisms of <code>Spawner</code> are quite "<i>reflective</i>". However, this thing
						would less likely be implemented into TerraModulus. Even if there is a need to have a
						machine to generate mobs, a better interface should be made to prevent low level code
						structure. Also, the way to detect daylight to skip spawning could be improved if the
						lighting system is changed.
					</p>
					<p> =19=
						<code>Tnt</code> may
						remain as <code>Furniture</code>, but more visual effects could be added. Also,
						interactions due to explosion could be standardized into general explosion algorithms
						for both entities and tiles, especially the factors of exposure and ranges, although
						the calculations of interactions of entities and tiles would still be separated. There
						would also be different attributes for an explosion. However, there might be different
						types of explosions, like gas or fire.
					</p>
					<p> =19=
						If the character moves from
						zero by walking, the velocity should increase gradually in a period like a second, to
						better simulate the motion.
					</p>
					<p> =18=
						The <code>walkDist</code> field in <code>Mob</code> only relates to the sprite animation
						but no other uses. Such data should be grouped together within an object, so that the
						objects could be responsible for the master class. The walking distance for statistics should also be handled
						by the move control. There should also be another object storing all the geologic data
						of the mob, like the position and direction. There is probably no need to have delay between
						attack damages; as for attack cooldowns, this should be implemented thoughtfully to
						balance the acts instead of receives, this kind of short period immunity may not make
						much sense. There might be a data monitoring object <code>Measure</code> to hold both the bounds
						and the actual counter of the value of measurement.
					</p>
					<p> =19=
						Knocking back by external motion would be
						handled by impact, that will be converted to a constant velocity to be resisted by
						resistance from the ground or air.
					</p>
					<p> =18=
						For spawning and despawning conditions of mobs, they may be changed depending on the
						design of the gameplay and the styles. To add a little realism, spawning of mobs may
						mostly be held during world generation without natural despawning.
						<code>noActionTime</code> in <code>Mob</code> is just for despawning check, and the
						<code>speed</code> field is also not useful.
					</p>
					<p> =17=
						The interactive box size is quite casual,
						the sizes may differ, while they may look similar in sprites. There is also no need to
						counter as <code>tickTime</code>. For temporary timers of events such as burning damages,
						there could be a pool of ticked handlers for each entity to tackle such work, without
						the need to bloat the code in the entity class while there is no much responsibility
						for the main class itself. Dead detection should be done in the health object;
						speed tweaking should be done in the move control, especially special treatment for
						speed effects.
					</p>
					<p> =09=
						For mob sprites, the compilation would be generalized into a kind of
						models.
					</p>
					<p> =18=
						Explosion damage would be sent from explosion directly to the
						entity, rather than an event interface <code>onExploded</code>.
					</p>
					<p> =23=
						The burn command to a mob could become a dynamic property of a mob, as a
						property assignment.
					</p>
					<p> =17=
						<code>MobAi</code> being a subclass does not make much sense. Several components of
						despawning, intelligent behaviors, automation, rendering, loots could be separated
						into different controls and handlers.
					</p>
					<p> =18=
						The level of mob is another mechanism, but unlikely to be generally implemented.
					</p>
					<p> =18=
						The generation of mobs should be handled in world generation.
					</p>
					<p> =17=
						For <code>EnemyMob</code>, the intelligent behavior would also be handled by the
						controls. The target tracking algorithm could be enhanced. The attacking range should
						also be larger than only touching. All the attacking methods should be combined into
						only one method taking a damage source as the parameter.
					</p>
					<p> =18=
						There is actually no need to have a field of <code>color</code> in
						<code>PassiveMob</code>. The behaviors like grazing could be more realistic, like
						having a countdown in the action. Both hostile and neutral mobs could have a list
						of enemies for tracking. In code, it seems like spawner is immune to creeper, but the
						way is too chaotic. Many mobs have only simple mechanisms without obvious difference.
					</p>
					<p> =09=
						If the models of mob are standardized, there is no need to have
						separate sprite sets for player carrying textures. Rendering of player is quite straightforward, like swimming
						and item holding, even falling, but item holding might but clearer, not only when
						they are being used.
					</p>
					<p> =17=
						<code>Player</code>: There are quite a number of exposed field
						when they are not hidden by using handlers, including the delay counters. The GUI-related parts
						should not be handled in the mob class. Potions effects could also be generalized
						into controls. Tile-related events by condition checking should be handled in tiles
						but not mobs when they are not mob-specific behaviors. Interactions would always pick
						the closest target within the range, or there would not be any interaction, especially
						when cursor could be supported, the target selection could be more precise; when there
						is entity blocking the target selection, the tile would never be selected even the
						entity has not reacted.
					</p>
					<p> =25=
						All fishing-related code should all be handled in the item class.
					</p>
					<p> =14=
						Item picking feature would be generalized to all mobs with slots.
					</p>
					<p> =17=
						<code>DamageSource</code> should take an argument with type inferred by the
						<code>DamageType</code>. The argument may contain one or more data, that could be
						used for various cases. <code>DamageType</code> should be changed into a regular
						class instead of enum for extensibility and public interface.
					</p>
					<p> =21=
						For particles, each particle entity should represent one unit of sprite for
						consistency. Also, they are not expected to have active interactions with other
						world objects. The <code>TextParticle</code> is actually not like particles, but other
						kind of visual effects, and the effects are too much for a particle. The mechanism of
						<code>WaterParticle</code> is actually too complex, but the code could have been
						simplified if initial velocities could be supported as general entity mechanisms.
					</p>
					<p> =09=
						When an item is being rendered, most of the time it would be on the Heads-Up Display
						(HUD) or in inventory menus. Other chances to be the sprites of item entities. The
						difference is that, when they are rendered on the Graphical User Interface (GUI),
						some extra information like durability may also be rendered along with the model of
						the item. Therefore, models and the GUI rendering functions would be separated for
						items.
					</p>
					<p> =23=
						The data part of item has failed, but all the metadata/properties and display
						information should have been separately provided for different usages by different
						ways, that description is one of the display information.
					</p>
					<p> =26=
						When items are linked by
						resource keys, there would not be the need to associate the sprites or models
						manually one by one.
					</p>
					<p> =14=
						Item stacks would be supported by an inventory provider that handles and constructs
						inventories and item managers. Items would have to configure based on the providers
						and managers, including the stacking criteria and limitations. It means that stacking
						size would not be directly hardcoded into items or stacks. Solely items could not be
						cloned, but the stacks. Depletion of items may be checked each time the stack is being
						handled; when there is change in the stack, the listener of the inventory manager
						would be invoked; interaction methods may return <code>true</code> for successful
						interactions, which may change the states of the stack.
					</p>
					<p> =23=
						Some attributes of items may be hardcoded for an item, but some may be dynamic.
						Internal attributes would become item properties while public ones would become item
						tags. Any of them could be either dynamic or static.
					</p>
					<p> =13=
						If the nature of books is to be an item in the world with content stored, it is not
						recommended to have them translated unless they are a special type of books. It is
						because there could be inconsistencies between server and client sides if the stored
						content may differ between different client settings. Thus, for the static books
						generated or originated from the game internals, like the "Antidious" book, they
						should be handled in a separate item instead of regular book item. This is to
						support client side translation, which clients would support. This means
						<code>BookData</code> would be an outdated structure. This kind of static content
						should be handled by assets instead of being in the code.
					</p>
					<p> =27=
						<code>BucketItem</code> should contain fluid instead of tile. Hole does not make sense
						but null since this kind of item is intended to contain actual fluid or liquid. The
						<code>offset</code> field is no longer useful when they are cut down to smaller
						sprites from an entire sprite sheet, could be replaced by <code>ordinal()</code>.
					</p>
					<p> =24=
						<code>ClothingItem</code> has been an issue for long time. There is actually no
						real use for the original mechanism, but it could be rewritten like Leather Armor
						in Minecraft.
					</p>
					<p> =24=
						In fact, dyes could be more flexible than having a small set of colors, but a wide
						range of colors like 32-bit RGB set. A limitation would be that dyed objects may
						be hardly modelled, so a blending or color mapping function may be necessary. A
						1-bit image could be used for tinting textures with the given tinting function.
					</p>
					<p> =25=
						<code>FishingData</code> could be turned into resources linked by resource keys.
						It might be more realistic if string could be broken when stretched too much, that
						players have to change the string. Fishing rods would be only able to catch fishing
						but not other items. Also, rods could be used anywhere.
					</p>
					<p> =23=
						If there would be a new food system with various recipes, the materials could contain
						fewer attributes as they are similar item type. Eating food would still cost stamina
						anyway.
					</p>
					<p> =22=
						The implementation of furniture item depends on the mechanism of furniture eventually.
						If all furniture could be held, players may be able to take them with bare hands or
						a helper item; if only certain furniture could be held, it would be inconsistent.
						On the other hand, if a furniture item associates the data with property, there must
						be a resource key registered without dynamic registration. Eventually, there could be
						furniture without having an item form if it is not automatically registered.
						Players would only be allowed to hold certain furniture, so it is possible that not
						all furniture may be normally accessible by player.
					</p>
					<p> =23=
						If there would be potion effects supported, they would be generally supported as an
						interface for all living mobs. Also, there would be a registry for storing all the
						potion effect types and the handlers, so that it could be a public interface.
					</p>
					<p> =22=
						<code>PowerGloveItem</code> still act as a placeholder for taking furniture. It could
						either be removed or rewritten depending on the future plans of the inventory
						system.
					</p>
					<p> =22=
						<code>TileItem</code> would still exist, that the items are placed tiles directly.
						However, it depends on the plans about how tiles should be done. It is still possible
						that they would just become the items to be used in creative mode only for fast
						placements of tiles. For <code>TileModel</code>, basically would be default data, but
						not keeping data, there is no reason to keep data in general when tiles could be
						stacked. If tiles may not be in item form, there might be a item type that with only
						one resource key but storing everything about tile in the metadata. The major factor
						for the places to be placed would be the type of tiles.
					</p>
					<p> =25=
						For <code>ToolType</code>, it would not be an enum, but a typical class, with all the
						instances stored as constants. All the <code>ToolItem</code> instances would use the
						references to the types for construction, without any looping. The tool type would be
						stored as item property. However, if all the tiles have a health system, there might
						not be a kind of mining level system for tools. Still, there could be two meters of
						health that when a suitable tool is used, a mining meter could be used. Also, if
						some tools could harvest a resource with only one action, the health meter could be
						ignored, and thus the aforementioned concern would be invalid. Durability of tool
						would not be set in the type but only in the item instances. It is possible that
						there could be a material that there is no a tool type specifically for it. For
						attack damage bonuses, there could be a mapping to collections for tools, taking
						attacker and attack targets as parameters, and eventually sent to the collection
						for the specific tool; the entire collection would then be registered to the tool.
					</p>
					<p> =02=
						Generally, if the loader cannot find the target object to be loaded for, an error
						should be emitted, indicating that the target resource is not found. Thus, there
						should not be an unknown object eventually loaded. <code>UnknownItem</code> would
						be discarded for consistency. When there is loading error, loading should be aborted
						in strict mode.
					</p>
					<p> =21=
						The glint particle in <code>WateringCanItem</code> should be registered. Besides,
						the splashing particles could be handled better, to a more generalized extent.
						The working mechanisms of this are actually quite magical, but could be rewritten.
						Also, it should not take the tile player selected as the target but the area of
						tiles close to the player.
					</p>
					<p> =14=
						The inventory system has actually organized quite neatly, but they should be placed
						in another package than <code>item</code>. However, if inventories tend to have
						slots, they should be using maps of slots than general lists; there might also be
						different sets of slots in an inventory storage. For an item to be stacked, all the
						metadata except counts of item should be same for the model of the simplified
						slot-counting-driven inventory system to work. If slots are supplied by the underlying
						storages, which would give the maximum sizes for the primary inventory.
					</p>
					<p> =14=
						The entire recipe system could actually be put into a separate package. If recipes
						are created using constructors or factor methods, there is completely no need to
						parse any string during constructions. Also, using references of instances is far
						more efficient than strings or names, even safer. All recipes would still have to
						be unlocked before being used, so the advancement system would still be used for
						this. The main method should be replaced by scripts, but due to the nature of
						scripts, they have a higher requirement than using the same environment as the
						code; recipes should be handled as resources than being coded.
					</p>
					<p> =23=
						All the tiles may have a list of properties,
						such as flammability, material type, hardness, blast resistance, luminosity, etc.
					</p>
					<p> =26=
						Instead of <code>Tile$Material</code>,
						Some tools may rely on various tile properties, but not with an enum. Identifiers may only
						be stored in the registry instead of within tile instance, but a resource entry may
						be returned to include the resource key along with the resource object. Other usages
						of this enum should be replaced by tile properties or metadata. Also, having this
						as argument may have limited the variations of tiles.
					</p>
					<p> =17=
						For tile interactions like the reactions when being stepped on or collided, they
						could be handled by standard methods in tiles and returning tile entities if they
						involve continuous followups. Factory method, like <code>onTileSet</code>, should
						be handled inside the scope where the tiles are set and initialized; certain
						initialization may also be set by the tile properties. Fluid tiles would be a
						special type of tiles, that there would be fluid mechanisms with these tiles.
						For the texture appearance of tile connections, they should be done in textures
						only. For the callbacks of tile destruction like mining and explosion, they should
						be made into a standard method accepting the destruction source or type. There is
						actually no need to have <code>getData</code> methods in tiles, when they should
						already be handled by chunk or tile managers.
					</p>
					<p> =20=
						Loots of tiles after breaking could be standardized by tile properties; damage
						multiplication should be managed by game rules, so it could be applied when
						there are damages acted on players. Automatic damage reviving actually makes
						no sense, while some tiles have no health, only handled by other interactions
						like mining.
					</p>
					<p> =07=
						<code>ConnectTile</code> should be removed. With a theoretically infinitely
						large world, there should be no boundaries visible or discoverable by players
						normally when players should be limited to the inner soft world boundaries
						with no normal access outside the boundaries.
					</p>
					<p> =26=
						There is no much advantage in using enum than general constructors and fields
						for <code>DecorTile</code>. Instead, when tiles are registered and stored as
						fields, the arguments would be directly passed into the constructors.
					</p>
					<p> =23=
						The metadata and models of a tile should not rely on the positions of the tile.
						The mechanisms of having variants of tiles in <code>DirtTile</code> do not obey
						this.
					</p>
					<p> =06=
						<code>FenceTile</code> is just an overlay tile over the ground tile, but parts
						of the code due to this simplified tile system are verbose.
					</p>
					<p> =06=
						Since <code>HoleTile</code> means nothing, it would be removed. Instead, there
						might be "<i>air tile</i>". This includes <code>InfiniteFallTile</code>.
					</p>
					<p> =20=
						<code>OreTile</code> and other rock tiles may drop loots for each mining action
						or when the tile is destroyed. The appearance would not be spiky.
					</p>
					<p> =07=
						There might also be some rocks tiles with little or more content of ores or other minerals.
					</p>
					<p> =06=
						Both <code>DirtTile</code> and <code>SandTile</code> would be the tiles that
						need support underneath. If there is no tile or just air tile, the tiles
						collapse. While walking on those tiles, there would be additional dust particles
						generated.
					</p>
					<p> =27=
						Some systems like plants may not purely rely on the tile instances but the classes
						of plants registered into the game. Then, tiles, items, etc., would be registered
						according to the registries of these plants. This includes trees, crops, flowers,
						grass, etc. Both <code>TreeTile</code>, <code>FlowerTile</code> and
						<code>CropTile</code> would be combined for mechanisms in this sense, although
						there might still be some differences in the details for different types of plants.
						This includes fertilization.
					</p>
					<p> =06=
						Since there would no longer be direct "level" by depths, but dimensions without
						obvious or close geographic relationships, <code>StairsTile</code> would be
						deprecated, but other stair-like tiles could be added for mob movement assistance.
						Those stair tiles could be made from various materials, but they could be as
						fragments or sections, even incomplete.
					</p>
					<p> =26=
						The approaches in <code>Tiles</code> and <code>Items</code> are quite low level and chaotic.
					</p>
					<p> =22=
						If <code>TorchTile</code> is a tile that could be picked up, it might better to
						be furniture. In fact, furniture is designed to be mobile, so player can pick them
						up if they are light enough, but tiles are not designed into this way, this design
						eventually causes inconsistencies in both logics and senses. This kind of tiles
						should be able to be put on wall tiles, as they are small decorative things logically.
					</p>
					<p> =28=
						<code>canWool</code> is actually a mechanism that does not really make sense. For the
						logic, this should be a feature that may be removed in the game. Also, having a
						carpet tile may be better than a wool tile.
					</p>
					<p> =26=
						If <code>FarmTile</code> is a variant of <code>DirtTile</code>, both could actually be
						combined in the mechanisms. When the dirt tile has reached a certain level of moisture
						and nutrition, crops could be growing on it. Thus, there is no need to add another
						tile, especially for a variant or a state of a tile. Crops may also grow and interact
						according to the status of the dirt tile underneath.
					</p>
					<p> =27=
						For the variations of crops and plants, there could be real-life species as well as
						fantasy species, like the heavenly berries and hellish berries. Mechanisms like
						harvesting, growing stages, diseases, nutrition, etc., would all be implemented for
						all kinds of plants.
					</p>
					<p> =06=
						The original system of fixed-sized levels would become dimensions of chunks. When
						world generation is unlimited by world size, structural generation should be
						independent of world size limitation. Each dimension would still have a display
						name. Each dimension would be assigned a seed generated by the world seed,
						but there would not be sizes. Even if the generator generates with a limited size
						of a world, other chunks would be empty but still accessible. Some metadata would
						be set during dimension construction, including maximum count of mobs. The container
						management for entities would be enclosed within a dimension and chunks, including
						counts, additions, removals and movements. The queues on the server side for entity
						additions and removals would be using linked lists and also enclosed in the entity
						manager. The entity managers for chunks may be associated with that of the dimension,
						so any change could be in synchronization. Entities may be grouped in a quadtree,
						so the chunks may manage them efficiently.
					</p>
					<p> =07=
						Only the chunk generator in the dimension would take the dimension seed as argument.
						Other events that take randomness would instead use thread random number generators.
						During the initialization of dimension, the generators would be initialized, but
						generation would not take place before generation commands were sent. It is not
						recommended to generate structures at a certain location on a world without any
						major pattern.
					</p>
					<p> =04=
						The order of ticking in a world is important. Any tick event may affect the
						positions and even the existence of entities, so all the entity existence events
						should be handled at the end of the entire ticking period. Also, since players
						consist of local players and remote players, ticking of them would depend on the
						transmissions of signals, but all the entities should be handled at the same time,
						including controls and existence, for synchronization and consistency. Then, the
						chunk managers would refresh the positions of the entities depending on their new
						coordinates with stages to efficiently manage them. If parallel processing of
						entities has to be implemented, certain ticking-related events should be separated
						and queued instead of being executed immediately for state synchronization.
					</p>
					<p> =06=
						All entities would be stored in two different maps. Each chunk would manage a single
						quadtree or k-d tree for all entities within the chunk; each dimension would manage
						all loaded chunks, with an indexer to query entities in the chunks within the
						dimension; each world would manage all loaded dimensions, with an indexer to query
						entities in the dimension, but also a global map mapping entity classes to the
						collections of entities. When searching nearest entity target, if a range is
						specified, only the selected chunks would be in consideration, nearest neighbor
						searching would be used; or entities would be filtered by the desired types using
						the map, then the collection would be looped through. However, for the selections
						that include all entities within a range, including ones on top of a tile, temporary
						geometries in the physics engine may be used to examine the collided objects,
						which do not only count in the centers of entities.
					</p>
					<p> =10=
						Background of the world would be handled by shaders, so the scene may not be static.
						Entity rendering would be controlled by rendering distance configured by the client.
						Light rendering would be controlled by shaders based on the tile light values,
						light blending and raytracing would also be programmed by shaders, without the
						information of entity lighting, including the sight blocking from player.
					</p>
					<p> =01=
						Coordinates, such as x and y, would not be treated as separate parameters. Instead,
						they would be consolidated into a single entity, particularly when representing a
						vector or an object's position. This approach ensures that positional data is conveyed
						as a unified parameter, whether in the form of a simple vector, a tile position
						referencing a dimension, or another integrated structure. When returning entries,
						like a tile from chunk manager, an entry describing the positions and the specified
						tile type with all the metadata included would be created, so the data could also be
						modified directly without invoking extra methods. Entity instantiations and removals
						may also be handled in the similar way.
					</p>
					<p> =18=
						If mobs are spawned only during world generation, additional natural spawning may
						not be implemented. Therefore, chunk manager would not handle any mob natural
						spawning interface. While all ordinary structures would only be spawned during
						world generation in the dedicated areas, no spawner-like device would be
						implemented. Village generation should actually be standardized like a general
						structure.
					</p>
					<p> =07=
						World generation would be handled by a manager with registries of generation
						parameters, functions and configurations. This would be aided by a random number
						generator with the seeds provided in the code for the generation process. The
						generator would always be available for chunk generations as the world is still
						loaded. All the generation configurations would not be hardcoded in the code but
						separately for the public customization interface. However, the primary functions
						would be supported by the interface for generator configuration, including sampling
						functions and random number generator algorithms.
					</p>
					<p> =07=
						If world size is theoretically unlimited, there is no need to validate anything
						when the generator is designed well. Also, it is challenging to design a suitable
						testing function to validate the content of the world, especially when they are
						generated parts by parts.
					</p>
					<p> =07=
						If world generation tends to be fancy, consisting of a lot of variations, it would
						not be simple as only with switch-cases, loops and if-else conditions. Also, even
						if the entire generation is desired to be fully programmed, constants should be
						more manageable, like being defined in the fields or the top level. The caves
						would not be horizontal.
					</p>
					<p> =07=
						The dungeon is an example of unordinary dimension generation, which is not set by
						general algorithms but major design patterns. The boss room and dungeon gate
						structure generations are the obvious evidence, they are generated toward the
						center. To support such generation patterns, there may be the need of scripts
						instead of simply just lists of attributes and properties. This means the system
						would not use data structures like JavaScript Object Notation (JSON).
					</p>
					<p> =07=
						The map generation testing function should not be included in the production code.
						The main reason is that it could become a redundant part of the release whilst not
						accessible without altering hidden launching parameters. There might another module
						to manually enter parameters to visually examining the results and the effectiveness
						of the configurations and algorithms.
					</p>
					<p> =07=
						Early world generations such as terrains would be done in the Rust part. After
						generation, chunk data would be sent back to the Kotlin part for further populations.
						Features are small scale decorative elements, being as tile placements, while
						structures are large scale templates and logics of tiles and entities with data and
						parameters. Jigsaws are presets of the templates to be used by structures. Most of
						them would come with custom data formats while generator configurations, features
						and structure definitions may come with scripting. This should be able to ensure
						that the supports are extensive, flexible, customizable, modularized and
						standardized enough.
					</p>
					<p> =02=
						Both <code>HistoricLoad</code> and <code>LegacyLoad</code> were developed to
						ensure compatibility with older versions of world saves. The former was initially
						implemented to support older save formats, but as the system evolved, the latter
						was subsequently introduced to further delineate the transition between the period
						when version tracking was not originally considered and the time when versioning
						became included. This distinction was necessary due to significant structural
						changes following the "legacy" phase, requiring a dedicated approach for handling
						older saves. <code>HistoricLoad</code> was specifically made to separate the difference between the stages when the save
						system did not yet support versioning and when it was supported. However, since
						there was also a big change after the "legacy" times, the code was separated to
						handle the older saves. Note that the new code of <code>HistoricLoad</code>
						realized the new approach in this codebase, with a brand-new style of strict
						conditional checking, which had never been used before, when mostly simple if-else
						and switch-case were used. The main factor was that most of the formats were simply
						text-based, comma-separated, or JSON, requiring a lot of string parsing. This was a
						new trial to reduce potential errors while providing as much minimal support as
						possible for old saves.
					</p>
					<p> =02=
						Additionally, <code>HistoricLoad</code> introduced a stricter conditional checking
						methodology in the codebase, moving away from previous implementations that relied
						predominantly on the simple if-else statements and switch-case logics. This change
						was driven by the reliance on text-based comma-separated values (CSV) format, which
						required extensive string parsing, while the following approach of using JSON also
						conforms to this. By using this approach, potential errors could be minimized while
						maintaining essential support for older saves.
					</p>
					<p> =02=
						Despite these refinements, the forthcoming comprehensive save system would adopt
						a scheme-driven approach to ensure robust backward compatibility. This framework
						would allow data fixing to be systematically integrated into the loading process,
						with older saves undergoing progressively more extensive fixes based on predefined
						schemes. These data fixers, expected to remain static and rigid, could be
						instantiated as singletons within the codebase. Loading exceptions would be managed
						with greater contextual detail, offering improved variations and information when
						errors or warnings arise. Exception behavior would vary depending on the mode: special
						accommodations in compatible mode and immediate failure in strict mode. File loading
						and format parsing would be assigned to lower-level components, particularly for
						custom formats. In such cases, JVM objects would be instantiated within the Rust
						part by the constructed Rust objects from parsing, though this would not apply to
						user preference settings. Serialization functionality could also be integrated
						within the system.
					</p>
					<p> =02=
						Save utilities would be managed independently rather than consolidated into a single
						<code>Save</code> class. Serialization would be implemented separately for different
						data objects, such as entities, ensuring that all dynamic tags being saved and
						included could be processed effectively. A dedicated class, <code>WorldSave</code>,
						would be introduced to specifically handle world save data, enabling a logical and
						structured serialization process. Regarding preference settings, general
						serialization could be applied since such configurations would already be structured
						in a key-value format based on the implementation. The Rust component would
						facilitate the encoding of serialized objects into the saves. It is important to note
						that save versioning would not correspond to the game or interface version; instead,
						it would be represented by a dedicated world save version number incremented
						sequentially as a standalone identifier.
					</p>
					<p> =12=
						Advancements and quests share similar properties and natures, so a common superclass
						should be made for simplification. A more important part is that most vanilla
						modularized components should be able to be easily disabled in the same public
						interface. There should be categories for advancements to organize for different
						topics of progress; would still be series for quests. Even if they have
						categorization, groupings may also be used within a category or a series, or in other
						words, a category or a series may contain more than one tree of elements. To let the
						progress be recorded, the elements or units could require both preceding elements
						and completion criteria to be both exist, that the criteria may be recorded preventing
						requiring repeated completion after the preceding elements being completed when they
						have already been fulfilled. All the elements would still be tree-linked with the
						preceding elements to be the requirement for the succeeding elements to be able to
						be completed. The configuration may no longer use JSON to define the structure for
						the ease of creation and parsing. When the preceding elements have already to be
						completed, the succeeding elements should be unlocked unless they are necessarily
						hidden; if completing an element requiring completing another element, it should be
						included as a kind of criteria instead of being a "requirement" as both "criterion"
						and "requirement" have similar meanings. Also, rewards should be abstract and with
						a list for each element. Each criterion may follow with description and the boolean
						value of whether to be visible. <code>AdvancementTrigger</code> should be renamed
						to <code>AdvancementTracker</code> for clarity. Trackers would also be in a registry,
						to let the conditions of criteria to be detected and fulfilled. In fact, trackers
						and condition handlers may also be constructed as anonymous classes. For working
						instances, they may have the references to the metadata of the elements and also
						the status of the elements for each tracking target, either global or player.
						Trackers should be using generic types to reduce the verbosity in using type
						checking. <code>Rangeable</code> should be separated into Minimum, Maximum and
						Range; <code>ItemConditions</code> could be simplified to a counting-based instead
						stack-based basis; there should be no no-op criterion and tracker but empty for the
						element to simplify the structure. During the processing of elements, the game
						should not be saved for progress synchronization. When passing a record to trackers
						to track for, a criterion working instance and the element working instance could
						be bundled in a new record object instead of being mutually included to simplify
						the structure.
					</p>
					<p> =12=
						Although most main utility parts of the advancement system are in the
						<code>AdvancementElement</code> class, since the amount of code is quite high, it
						would still be better to separate the content for different responsibilities in a
						separate package. If recipes can be disabled, they should be in a separate public
						interface, so not only advancements could be able to handle recipe locking. An
						advancement category may be per-user basis or global, depending on the nature of
						the topic.
					</p>
					<p> =12=
						A different of quests from advancements is that quests may have prerequisites to
						be unlocked before to be able to be completed, so the completing criteria may not
						even be tracked before being unlocked. However, the quest system would follow the
						similar structure as the advancement system since the original style has been
						outdated.
					</p>
					<p> =01=
						Most functions in <code>MyUtils</code> could be replaced by the helper functions
						from various utility libraries. If there are functions designed specifically for
						this codebase, they may actually be declared as top level functions for simplicity.
					</p>
					<p> =01=
						Unfortunately, due to the coordinate system implementation, the <code>Vector2</code>
						class is not fully utilized in code. There would be several classes to represent
						different forms of vectors with different parameters and properties. However, it
						is important to note that they should all be record classes with all the fields
						immutable, to be treated as primitive-like values.
					</p>
				</content>
			</section>
			<section title="Extra Notes">
				<content>
					<p>
						While doing the low level programming anywhere, even in the Kotlin parts, careful
						coding is always required. It means, extra attentions are always needed, to ensure
						the logics make sense without heavily relying on the compiler while the compiler
						may not give valuable information just by the errors or warnings. This is especially
						important while porting low level APIs to the higher level places, since it may
						sometimes be forgotten.
					</p>
					<p>
						When there are some utility classes, the internal code may be somehow lower level,
						so the above rules apply. Also, the resultant syntax of the usages should be
						idiomatic in Kotlin or even practical according to the code patterns.
					</p>
					<p> =02=
						The way to handle world events, activities and commands should be carefully studied.
						It may skip the desired code if not handled properly. It includes teleporting
						entities across dimensions. The necessary unprocessed events should not be ignored
						if there exists any.
					</p>
					<p>
						Listeners must be handled well. They are registered when they are set up, but they
						should be unregistered when the holders of the event listeners are destroyed, or
						they are no longer used. There should be no "zombie" listeners happening. This
						could only be ensured by the developers, and the compiler could not validate this.
						Try-finally may be used if it is inside a try-catch block.
					</p>
					<p>
						In fact, when the constructions of classes are limited, as long as they are still
						in the scope of context, they should be safe to be public. This covers the cases
						when particularly some classes are doing their responsibilities in their domains
						for other parts. This case, if the source data are from the other parts where the
						creations are already limited and the classes in the domain are using the source
						data with the publicly exposed classes definitions, the source data are still
						limited in the scope safely even they are in the other domains as long as they
						are well-designed.
					</p>
					<p>
						Visibilities of code entities should be handled well and logical enough. If there
						exist some functions or constants that are general, they could be considered
						being moved out of the class. Also, if some members are designed to be used in
						a specific scope, they should not be highly visible to prevent breaking mechanisms.
					</p>
					<p>
						If a numerical countdown involves a specific event as designed, it should not be
						made as a countup unless there are more events associated to this counter. However,
						specifically, if the event dominates, there may still be a countdown designed for
						the event and the countup for the others. If it involves time, increment or decrement
						should be done at the end of the ticking function, and all the conditions regarding
						the counter should be done prior than counter updates.
					</p>
					<p>
						When there is no necessity, avoid singletons. This is to avoid unnecessary verbosity
						caused by the extra unused code regenerated by declaring classes as singletons.
					</p>
					<p>
						For a single file, there should be no more than two levels of inner classes in
						general. This is to prevent unnecessary verbosity and ensure simplicity,
						organization and readability of class structures.
					</p>
					<p>
						Extension functions should be used wisely to prevent unnecessary pollutions. This may
						greatly affect coding experience.
					</p>
					<p>
						Classes that are solely referenced by another class within a package containing multiple
						related components should ideally be nested within the class utilizing them,
						particularly when thematic organization applies.
					</p>
					<p>
						There should be a guideline that when initializations of fields are enough to be inlined,
						they should be kept there and not put into initialization block.
					</p>
				</content>
			</section>
		</section>
		<section title="Feature Implementation">
			<content>
				<p> =08=
					Errors, would be popped up with information only when the errors occurred before
					the completion of rendering initialization or the error is in or out of the scope
					of the application. For error catching, only documented errors should be included,
					unless it is in the major catch block or the error handler.
				</p>
				<p>
					When it is possible to not use string keys, they should be avoided. Instead, defined constants
					or enums would be used. It is because any errors caused with the strings could only
					sometimes be known in runtime, thus there could be potential bugs. It could also
					cause extra performance overheads in runtime by string representation and parsing.
				</p>
				<p> =29=
					The audio system would be remade with using OpenAL. Several features would be
					implemented. And note that no mixing algorithm would be used, only simple additions.
					This should ensure the quality of audio with consistency. When not in game, there would
					only be UI sounds and BGM; when in game, other sounds only come from the world. There
					should be no limitation with in-game sound sources, but seemingly only 2 major sources
					for non-game elements. Further implementation would be handed in the future asset
					system.
				</p>
				<p> =03=
					Many menu components are certainly required to be updated. This includes the hot bar
					and several menu frames. However, this part relates to graphics which would be discussed
					at the later stage. Rendering system may be mostly implemented ourselves for the best
					compatibility and usages, but it is still worth finding an existing meshing, modelling or
					sprite library for backing.
				</p>
				<p> =04=
					Sleeping mechanisms would be updated later. Actually, a compromise way ensuring
					consistency for both game time speed and continuous game events is to not skip or
					acceleration the time. However, a problem here is that the nighttime could be too
					long for some intentions. To solve this, <i>a world of dream</i> could be implemented
					during sleeping, with each world a single player dimension, that if the player received
					a large amount of damage or died, the player wakes up immediately from bed. The
					corresponding biological health system would be made for this. The player would be
					allowed to sleep at any time, only when the character is tired enough. This way,
					various consistencies could be attained while the player could still be in the gameplay.
					Detailed implementation would be discussed later. This could also avoid performance
					issues that may be caused by speeding up game ticking during the time period.
				</p>
				<p> =01=
					Some utility classes could be made for synchronization. For some places, synchronized
					maps and collections are needed, but the syntax should be more straightforward, like
					the <code>Mutex</code> or <code>ReadWriteLock</code> in Rust. A similarly favored class
					could be made for generic instances holding internally by the constructor with the new
					instances. This could only be ensured by the developer writing the code, though.
				</p>
				<p> =11=
					A input masking session could be made for each tick for input state checking for menus.
					This could be managed by the <code>MenuManager</code>. This way, when the processing
					menu requires the specific inputs which may be mappings, to be hidden for the queued
					menus, even fully hidden, it could be done dynamically and on demand. It would also
					not affect global checking for a physical key outside the menu ticking session, though
					it might not be necessary or practical.
				</p>
				<p> =04=
					The time enums for each part of a day may not be that regular as quarters, especially
					when 0 would be set as the midnight or midday. As seasons and seasonal day length may
					be implemented in the future, there might be definite constants specifying the part of
					a day. The way Minecraft handles may be taken as reference, although the day time tick
					does not align with the actual real world time system on which how 0 is defined. Detailed
					implementation would be discussed and decided later.
				</p>
				<p> =06=
					According to the future plan of implementation of the world system, there would be
					no the depth indices for each dimension, and there are no levels but dimensions.
					There is not yet the concept of "level" in the proposed ideas actually.
				</p>
				<p> =04=
					As for client IDs, UUIDs with special tricks would be used. On the server side, all the
					client IDs are recorded, and associated to account IDs. Account IDs would be unique
					UUIDs guaranteed by the server database, also used as server player entity IDs (EIDs).
					These EIDs would be unique within the server, or the world, in which the player EIDs
					would be appended with an identifier for players, distinguished from other entities.
					The client IDs would be unique, so it is allowed to launch instances of the Launcher
					on different client devices at the same time, but not allowed to have 2 client instances
					connected to the server with the same client ID, or a new client ID would be regenerated.
					However, no 2 or more clients could be connected to the sane server with the same
					account. Also, in single player, to be allowed in offline gameplay, the player EID would
					be the default ID hardcoded in the game, but translated to player EID by the account ID,
					allowing guest modes without accounts. Although it could be more convenient to implement
					if guest mode is not implemented that the account player EID is always used in the game,
					so no worry that server worlds could not be played offline. Of course all these things
					would assume that no one edited the information in an unideal way.
				</p>
				<p> =04=
					Certainly, EIDs are not something really "network", but it is originally placed in
					<code>Network</code>. This would probably be handled as utils or with a dedicated
					category instead.
				</p>
				<p> =04=
					As for synchronization between clients, the decisions of changes would be made by
					the server, so if the server decide that the player acts are invalid, they could
					be ignored or just reversed.
				</p>
				<p> =03=
					The way to handle the toggle of hardware acceleration is still a question. In
					general, there is no need to turn off hardware acceleration, but in rare cases
					the graphics cards may not be compatible with the software, so they may have to
					be turned off. However, if it has already malfunctioned when the application has
					launched, the toggle in application is quite unusable. They should either be
					configured by launching arguments or handled internally by the application.
				</p>
			</content>
		</section>
		<section title="Development Roadmap and Direction">
			<content>
				<p>

				</p>
			</content>
		</section>
	</body>
</efp>
